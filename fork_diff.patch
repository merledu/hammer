diff --git a/README.md b/README.md
index a47d0ec..52804d4 100644
--- a/README.md
+++ b/README.md
@@ -19,6 +19,8 @@ Infrastructure to drive Spike (RISC-V ISA Simulator) in cosim mode. Hammer provi
 python3 -m pip install pybind11
 ```
 * Libraries and headers from Spike
+* Hammer was last tested with Spike commit `3349dc51`. Checkout this commit in
+  Spike before building.
 
 In the Spike repo run:
 
@@ -30,7 +32,7 @@ make
 make install
 ```
 
-The SHA of the last tested Spike version is included in the name of the patch file.
+Hammer was last tested with Spike commit `3349dc51`.
 
 ## Building Hammer and Running Tests
 
diff --git a/ham.log b/ham.log
new file mode 100644
index 0000000..07a0e3d
--- /dev/null
+++ b/ham.log
@@ -0,0 +1,256 @@
+core   0: 3 0x00001000 (0x00000297) x5  0x00001000
+core   0: 3 0x00001004 (0x02028593) x11 0x00001020
+core   0: 3 0x00001008 (0xf1402573) x10 0x00000000
+core   0: 3 0x0000100c (0x0182a283) x5  0x80000080 mem 0x00001018
+core   0: 3 0x00001010 (0x00028067)
+core   0: 3 0x80000080 (0x40001137) x2  0x40001000
+core   0: 3 0x80000084 (0x10410113) x2  0x40001104
+core   0: 3 0x80000088 (0x30111073) c769_misa 0x40141104
+core   0: 3 0x8000008c (0x00010517) x10 0x8001008c
+core   0: 3 0x80000090 (0xbf850513) x10 0x8000fc84
+core   0: 3 0x80000094 (0x00000117) x2  0x80000094
+core   0: 3 0x80000098 (0xf6c10113) x2  0x80000000
+core   0: 3 0x8000009c (0x00116113) x2  0x80000001
+core   0: 3 0x800000a0 (0x30511073) c773_mtvec 0x80000001
+core   0: 3 0x800000a4 (0x00000117) x2  0x800000a4
+core   0: 3 0x800000a8 (0x00c10113) x2  0x800000b0
+core   0: 3 0x800000ac (0x34111073) c833_mepc 0x800000b0
+core   0: 3 0x800000b0 (0x80000037)
+core   0: 3 0x800000b4 (0x0001)
+core   0: 3 0x800000b6 (0xf54a30b7) x1  0xf54a3000
+core   0: 3 0x800000ba (0xb8d08093) x1  0xf54a2b8d
+core   0: 3 0x800000be (0x412d) x2  0x0000000b
+core   0: 3 0x800000c0 (0x400aa1b7) x3  0x400aa000
+core   0: 3 0x800000c4 (0xc7318193) x3  0x400a9c73
+core   0: 3 0x800000c8 (0xe2857237) x4  0xe2857000
+core   0: 3 0x800000cc (0x1d720213) x4  0xe28571d7
+core   0: 3 0x800000d0 (0x977142b7) x5  0x97714000
+core   0: 3 0x800000d4 (0xdfc28293) x5  0x97713dfc
+core   0: 3 0x800000d8 (0x4301) x6  0x00000000
+core   0: 3 0x800000da (0x032433b7) x7  0x03243000
+core   0: 3 0x800000de (0x82538393) x7  0x03242825
+core   0: 3 0x800000e2 (0x80000437) x8  0x80000000
+core   0: 3 0x800000e6 (0x4495) x9  0x00000005
+core   0: 3 0x800000e8 (0x459d) x11 0x00000007
+core   0: 3 0x800000ea (0xf2fd2637) x12 0xf2fd2000
+core   0: 3 0x800000ee (0xee760613) x12 0xf2fd1ee7
+core   0: 3 0x800000f2 (0x4e2676b7) x13 0x4e267000
+core   0: 3 0x800000f6 (0xeb568693) x13 0x4e266eb5
+core   0: 3 0x800000fa (0xffd5e737) x14 0xffd5e000
+core   0: 3 0x800000fe (0xe6770713) x14 0xffd5de67
+core   0: 3 0x80000102 (0x4785) x15 0x00000001
+core   0: 3 0x80000104 (0x4801) x16 0x00000000
+core   0: 3 0x80000106 (0xc00018b7) x17 0xc0001000
+core   0: 3 0x8000010a (0x78e88893) x17 0xc000178e
+core   0: 3 0x8000010e (0x494899b7) x19 0x49489000
+core   0: 3 0x80000112 (0x19b5) x19 0x49488fed
+core   0: 3 0x80000114 (0x80000a37) x20 0x80000000
+core   0: 3 0x80000118 (0x80000ab7) x21 0x80000000
+core   0: 3 0x8000011c (0x4b25) x22 0x00000009
+core   0: 3 0x8000011e (0x4b81) x23 0x00000000
+core   0: 3 0x80000120 (0xfd1f5c37) x24 0xfd1f5000
+core   0: 3 0x80000124 (0x3eac0c13) x24 0xfd1f53ea
+core   0: 3 0x80000128 (0x4c91) x25 0x00000004
+core   0: 3 0x8000012a (0x4d01) x26 0x00000000
+core   0: 3 0x8000012c (0x4da9) x27 0x0000000a
+core   0: 3 0x8000012e (0x80000e37) x28 0x80000000
+core   0: 3 0x80000132 (0x4e81) x29 0x00000000
+core   0: 3 0x80000134 (0x4f01) x30 0x00000000
+core   0: 3 0x80000136 (0xd2e78fb7) x31 0xd2e78000
+core   0: 3 0x8000013a (0x693f8f93) x31 0xd2e78693
+core   0: 3 0x8000013e (0x0000b917) x18 0x8000b13e
+core   0: 3 0x80000142 (0xd2690913) x18 0x8000ae64
+core   0: 3 0x80000146 (0xa009)
+core   0: 3 0x80000148 (0x03843033)
+core   0: 3 0x8000014c (0x01342033)
+core   0: 3 0x80000150 (0x00ac4033)
+core   0: 3 0x80000154 (0x413db113) x2  0x00000001
+core   0: 3 0x80000158 (0x009fd013)
+core   0: 3 0x8000015c (0x03c22e33) x28 0xf142b8eb
+core   0: 3 0x80000160 (0x41a608b3) x17 0xf2fd1ee7
+core   0: 3 0x80000164 (0x001510b3) x1  0x1f908000
+core   0: 3 0x80000168 (0xcee5)
+core   0: 3 0x8000016a (0x03395233) x4  0x00000001
+core   0: 3 0x8000016e (0x4131d033)
+core   0: 3 0x80000172 (0x99b6) x19 0x976efea2
+core   0: 3 0x80000174 (0x987d) x8  0x80000000
+core   0: 3 0x80000176 (0x0e466063)
+core   0: 3 0x8000017a (0x8c55) x8  0xce266eb5
+core   0: 3 0x8000017c (0x00004417) x8  0x8000417c
+core   0: 3 0x80000180 (0xd8f40413) x8  0x80003f0b
+core   0: 3 0x80000184 (0xf8141b03) x22 0xffffd015 mem 0x80003e8c
+core   0: 3 0x80000188 (0x09440223) mem 0x80003f8f 0x00
+core   0: 3 0x8000018c (0x44f9) x9  0x0000001e
+core   0: 3 0x8000018e (0xf3344f83) x31 0x0000008f mem 0x80003e3e
+core   0: 3 0x80000192 (0x8ccd) x9  0x0000001f
+core   0: 3 0x80000194 (0x6155) x2  0x00000131
+core   0: 3 0x80000196 (0xf3040683) x13 0xffffffa8 mem 0x80003e3b
+core   0: 3 0x8000019a (0x07942a83) x21 0x4f453da7 mem 0x80003f84
+core   0: 3 0x8000019e (0x0a242a23) mem 0x80003fbf 0x00000131
+core   0: 3 0x800001a2 (0x07941b03) x22 0x00003da7 mem 0x80003f84
+core   0: 3 0x800001a6 (0xf2941ca3) mem 0x80003e44 0x001f
+core   0: 3 0x800001aa (0x042422a3) mem 0x80003f50 0x00000131
+core   0: 3 0x800001ae (0x022425a3) mem 0x80003f36 0x00000131
+core   0: 3 0x800001b2 (0x95d2) x11 0x80000007
+core   0: 3 0x800001b4 (0xfcc42a83) x21 0x84a5f604 mem 0x80003ed7
+core   0: 3 0x800001b8 (0x616d) x2  0x00000221
+core   0: 3 0x800001ba (0x024314b3) x9  0x00000000
+core   0: 3 0x800001be (0x010829b3) x19 0x00000000
+core   0: 3 0x800001c2 (0x41a65813) x16 0xfffffffc
+core   0: 3 0x800001c6 (0x019b5db3) x27 0x000003da
+core   0: 3 0x800001ca (0x01339113) x2  0x41280000
+core   0: 3 0x800001ce (0x0e941023) mem 0x80003feb 0x0000
+core   0: 3 0x800001d2 (0xfa244f83) x31 0x0000000b mem 0x80003ead
+core   0: 3 0x800001d6 (0x6c39) x24 0x0000e000
+core   0: 3 0x800001d8 (0xfe242e23) mem 0x80003f07 0x41280000
+core   0: 3 0x800001dc (0xf9b41b03) x22 0x0000524e mem 0x80003ea6
+core   0: 3 0x800001e0 (0x409d55b3) x11 0x00000000
+core   0: 3 0x800001e4 (0x8691) x13 0xfffffffa
+core   0: 3 0x800001e6 (0xf4242f23) mem 0x80003e69 0x41280000
+core   0: 3 0x800001ea (0x07440aa3) mem 0x80003f80 0x00
+core   0: 3 0x800001ee (0x0176d113) x2  0x000001ff
+core   0: 3 0x800001f2 (0x0d544f83) x31 0x00000073 mem 0x80003fe0
+core   0: 3 0x800001f6 (0x8ed1) x13 0xffffffff
+core   0: 3 0x800001f8 (0xe01ae717) x14 0x601ae1f8
+core   0: 3 0x800001fc (0x0e944f83) x31 0x000000d0 mem 0x80003ff4
+core   0: 3 0x80000200 (0x0286af33) x30 0xffffffff
+core   0: 3 0x80000204 (0x01b7b593) x11 0x00000001
+core   0: 3 0x80000208 (0xf3245003) mem 0x80003e3d
+core   0: 3 0x8000020c (0x01142a83) x21 0x434a6c7d mem 0x80003f1c
+core   0: 3 0x80000210 (0x80c6) x1  0xf2fd1ee7
+core   0: 3 0x80000212 (0x48f18013)
+core   0: 3 0x80000216 (0xf4e40683) x13 0xfffffff3 mem 0x80003e59
+core   0: 3 0x8000021a (0xfbc45003) mem 0x80003ec7
+core   0: 3 0x8000021e (0x3e8b3193) x3  0x00000000
+core   0: 3 0x80000222 (0x6149) x2  0x0000028f
+core   0: 3 0x80000224 (0xff440f23) mem 0x80003f09 0x00
+core   0: 3 0x80000228 (0xfe141b03) x22 0xffff8d13 mem 0x80003eec
+core   0: 3 0x8000022c (0x0e242ca3) mem 0x80004004 0x0000028f
+core   0: 3 0x80000230 (0x05440023) mem 0x80003f4b 0x00
+core   0: 3 0x80000234 (0xfdc45003) mem 0x80003ee7
+core   0: 3 0x80000238 (0xfd440ea3) mem 0x80003ee8 0x00
+core   0: 3 0x8000023c (0x04942a83) x21 0xe1b99538 mem 0x80003f54
+core   0: 3 0x80000240 (0x41735cb3) x25 0x00000000
+core   0: 3 0x80000244 (0x88703c13) x24 0x00000001
+core   0: 3 0x80000248 (0x01ac6b33) x22 0x00000001
+core   0: 3 0x8000024c (0x00d80fb3) x31 0xffffffef
+core   0: 3 0x80000250 (0x86fd) x13 0xffffffff
+core   0: 3 0x80000252 (0xb9b3c613) x12 0xfcdbd3be
+core   0: 3 0x80000256 (0x95aa) x11 0x8000fc85
+core   0: 3 0x80000258 (0x0001)
+core   0: 3 0x8000025a (0x02cc5433) x8  0x00000000
+core   0: 3 0x8000025e (0x8df1) x11 0x8000d084
+core   0: 3 0x80000260 (0x54d57d93) x27 0x00000404
+core   0: 3 0x80000264 (0x6135) x2  0x000003ef
+core   0: 3 0x80000266 (0x021d1fb3) x31 0x00000000
+core   0: 3 0x8000026a (0x009b0863)
+core   0: 3 0x8000026e (0x8d81ec37) x24 0x8d81e000
+core   0: 3 0x80000272 (0x0dfa) x27 0x00000000
+core   0: 3 0x80000274 (0x86b9) x13 0xffffffff
+core   0: 3 0x80000276 (0x016e7233) x4  0x00000001
+core   0: 3 0x8000027a (0x00457c63)
+core   0: 3 0x80000292 (0x418b58b3) x17 0x00000001
+core   0: 3 0x80000296 (0x4185) x3  0x00000001
+core   0: 3 0x80000298 (0xc199)
+core   0: 3 0x8000029a (0x40ec8033)
+core   0: 3 0x8000029e (0x8ba5) x15 0x00000001
+core   0: 3 0x800002a0 (0x01cb2333) x6  0x00000000
+core   0: 3 0x800002a4 (0x01a3d213) x4  0x00000000
+core   0: 3 0x800002a8 (0x007a9663)
+core   0: 3 0x800002b4 (0x014a) x2  0x0fbc0000
+core   0: 3 0x800002b6 (0x8cef7037)
+core   0: 3 0x800002ba (0x00211fb3) x31 0x0fbc0000
+core   0: 3 0x800002be (0x0001)
+core   0: 3 0x800002c0 (0x0c26) x24 0x03c00000
+core   0: 3 0x800002c2 (0x0399d463)
+core   0: 3 0x800002ea (0x017e9213) x4  0x00000000
+core   0: 3 0x800002ee (0x01f35d93) x27 0x00000000
+core   0: 3 0x800002f2 (0x0001)
+core   0: 3 0x800002f4 (0x8ac1) x13 0x00000010
+core   0: 3 0x800002f6 (0x643d) x8  0x0000f000
+core   0: 3 0x800002f8 (0x8dc9) x11 0x8000fc84
+core   0: 3 0x800002fa (0x00cfed63)
+core   0: 3 0x80000314 (0x00c80233) x4  0xfcdbd3ba
+core   0: 3 0x80000318 (0x00000e97) x29 0x80000318
+core   0: 3 0x8000031c (0x00ce8e93) x29 0x80000324
+core   0: 3 0x80000320 (0x000e8067)
+core   0: 3 0x80000324 (0x4185) x3  0x00000001
+core   0: 3 0x80000000 (0x6fc0106f)
+core   0: 3 0x800016fc (0x34091973) x18 0x00000000 c832_mscratch 0x8000ae64
+core   0: 3 0x80001700 (0x00050933) x18 0x8000fc84
+core   0: 3 0x80001704 (0xf8490913) x18 0x8000fc08
+core   0: 3 0x80001708 (0x00192223) mem 0x8000fc0c 0xf2fd1ee7
+core   0: 3 0x8000170c (0x00292423) mem 0x8000fc10 0x0fbc0000
+core   0: 3 0x80001710 (0x00392623) mem 0x8000fc14 0x00000001
+core   0: 3 0x80001714 (0x00492823) mem 0x8000fc18 0xfcdbd3ba
+core   0: 3 0x80001718 (0x00592a23) mem 0x8000fc1c 0x97713dfc
+core   0: 3 0x8000171c (0x00692c23) mem 0x8000fc20 0x00000000
+core   0: 3 0x80001720 (0x00792e23) mem 0x8000fc24 0x03242825
+core   0: 3 0x80001724 (0x02892023) mem 0x8000fc28 0x0000f000
+core   0: 3 0x80001728 (0x02992223) mem 0x8000fc2c 0x00000000
+core   0: 3 0x8000172c (0x02a92423) mem 0x8000fc30 0x8000fc84
+core   0: 3 0x80001730 (0x02b92623) mem 0x8000fc34 0x8000fc84
+core   0: 3 0x80001734 (0x02c92823) mem 0x8000fc38 0xfcdbd3be
+core   0: 3 0x80001738 (0x02d92a23) mem 0x8000fc3c 0x00000010
+core   0: 3 0x8000173c (0x02e92c23) mem 0x8000fc40 0x601ae1f8
+core   0: 3 0x80001740 (0x02f92e23) mem 0x8000fc44 0x00000001
+core   0: 3 0x80001744 (0x05092023) mem 0x8000fc48 0xfffffffc
+core   0: 3 0x80001748 (0x05192223) mem 0x8000fc4c 0x00000001
+core   0: 3 0x8000174c (0x05292423) mem 0x8000fc50 0x8000fc08
+core   0: 3 0x80001750 (0x05392623) mem 0x8000fc54 0x00000000
+core   0: 3 0x80001754 (0x05492823) mem 0x8000fc58 0x80000000
+core   0: 3 0x80001758 (0x05592a23) mem 0x8000fc5c 0xe1b99538
+core   0: 3 0x8000175c (0x05692c23) mem 0x8000fc60 0x00000001
+core   0: 3 0x80001760 (0x05792e23) mem 0x8000fc64 0x00000000
+core   0: 3 0x80001764 (0x07892023) mem 0x8000fc68 0x03c00000
+core   0: 3 0x80001768 (0x07992223) mem 0x8000fc6c 0x00000000
+core   0: 3 0x8000176c (0x07a92423) mem 0x8000fc70 0x00000000
+core   0: 3 0x80001770 (0x07b92623) mem 0x8000fc74 0x00000000
+core   0: 3 0x80001774 (0x07c92823) mem 0x8000fc78 0xf142b8eb
+core   0: 3 0x80001778 (0x07d92a23) mem 0x8000fc7c 0x80000324
+core   0: 3 0x8000177c (0x07e92c23) mem 0x8000fc80 0xffffffff
+core   0: 3 0x80001780 (0x07f92e23) mem 0x8000fc84 0x0fbc0000
+core   0: 3 0x80001784 (0x34102173) x2  0x80000326
+core   0: 3 0x80001788 (0x34202173) x2  0x0000000b
+core   0: 3 0x8000178c (0x4fad) x31 0x0000000b
+core   0: 3 0x8000178e (0x01f10d63)
+core   0: 3 0x800017a8 (0xfffff117) x2  0x800007a8
+core   0: 3 0x800017ac (0x8d810113) x2  0x80000080
+core   0: 3 0x800017b0 (0xc002) mem 0x80000080 0x00000000
+core   0: 3 0x800017b2 (0xc206) mem 0x80000084 0xf2fd1ee7
+core   0: 3 0x800017b4 (0xc40a) mem 0x80000088 0x80000080
+core   0: 3 0x800017b6 (0xc60e) mem 0x8000008c 0x00000001
+core   0: 3 0x800017b8 (0xc812) mem 0x80000090 0xfcdbd3ba
+core   0: 3 0x800017ba (0xca16) mem 0x80000094 0x97713dfc
+core   0: 3 0x800017bc (0xcc1a) mem 0x80000098 0x00000000
+core   0: 3 0x800017be (0xce1e) mem 0x8000009c 0x03242825
+core   0: 3 0x800017c0 (0xd022) mem 0x800000a0 0x0000f000
+core   0: 3 0x800017c2 (0xd226) mem 0x800000a4 0x00000000
+core   0: 3 0x800017c4 (0xd42a) mem 0x800000a8 0x8000fc84
+core   0: 3 0x800017c6 (0xd62e) mem 0x800000ac 0x8000fc84
+core   0: 3 0x800017c8 (0xd832) mem 0x800000b0 0xfcdbd3be
+core   0: 3 0x800017ca (0xda36) mem 0x800000b4 0x00000010
+core   0: 3 0x800017cc (0xdc3a) mem 0x800000b8 0x601ae1f8
+core   0: 3 0x800017ce (0xde3e) mem 0x800000bc 0x00000001
+core   0: 3 0x800017d0 (0xc0c2) mem 0x800000c0 0xfffffffc
+core   0: 3 0x800017d2 (0xc2c6) mem 0x800000c4 0x00000001
+core   0: 3 0x800017d4 (0xc4ca) mem 0x800000c8 0x8000fc08
+core   0: 3 0x800017d6 (0xc6ce) mem 0x800000cc 0x00000000
+core   0: 3 0x800017d8 (0xc8d2) mem 0x800000d0 0x80000000
+core   0: 3 0x800017da (0xcad6) mem 0x800000d4 0xe1b99538
+core   0: 3 0x800017dc (0xccda) mem 0x800000d8 0x00000001
+core   0: 3 0x800017de (0xcede) mem 0x800000dc 0x00000000
+core   0: 3 0x800017e0 (0xd0e2) mem 0x800000e0 0x03c00000
+core   0: 3 0x800017e2 (0xd2e6) mem 0x800000e4 0x00000000
+core   0: 3 0x800017e4 (0xd4ea) mem 0x800000e8 0x00000000
+core   0: 3 0x800017e6 (0xd6ee) mem 0x800000ec 0x00000000
+core   0: 3 0x800017e8 (0xd8f2) mem 0x800000f0 0xf142b8eb
+core   0: 3 0x800017ea (0xdaf6) mem 0x800000f4 0x80000324
+core   0: 3 0x800017ec (0xdcfa) mem 0x800000f8 0xffffffff
+core   0: 3 0x800017ee (0xdefe) mem 0x800000fc 0x0000000b
+core   0: 3 0x800017f0 (0x34102173) x2  0x80000326
+core   0: 3 0x800017f4 (0x0111) x2  0x8000032a
+core   0: 3 0x800017f6 (0x34111073) c833_mepc 0x8000032a
+core   0: 3 0x800017fa (0x30200073) c768_mstatus 0x00000080 c784_mstatush 0x00000000
+core   0: 3 0x8000032a (0x00002f17) x30 0x8000232a
+core   0: 3 0x8000032e (0xcc3f2b23) mem 0x80002000 0x00000001
diff --git a/hammer.cpp b/hammer.cpp
index db48905..ff528c2 100644
--- a/hammer.cpp
+++ b/hammer.cpp
@@ -10,10 +10,11 @@
 
 #include <vector>
 
+
 // FIXME: This function exists in Spike as a static function. We shouldn't have to
 // copy it out here but sim_t requires it as an argument.
-static std::vector<std::pair<reg_t, mem_t *>> make_mems(const std::vector<mem_cfg_t> &layout) {
-  std::vector<std::pair<reg_t, mem_t *>> mems;
+static std::vector<std::pair<reg_t, abstract_mem_t*>> make_mems(const std::vector<mem_cfg_t> &layout) {
+  std::vector<std::pair<reg_t, abstract_mem_t*>> mems;
   mems.reserve(layout.size());
   for (const auto &cfg : layout) {
     mems.push_back(std::make_pair(cfg.get_base(), new mem_t(cfg.get_size())));
@@ -26,6 +27,8 @@ Hammer::Hammer(const char *isa, const char *privilege_levels, const char *vector
                const std::string target_binary, const std::optional<uint64_t> start_pc) {
   // Expose these only if needed
   std::vector<std::pair<reg_t, abstract_device_t *>> plugin_devices;
+  std::vector<std::pair<const device_factory_t*, std::vector<std::string>>> plugin_device_factories;
+
   debug_module_config_t dm_config = {.progbufsize = 2,
                                      .max_sba_data_width = 0,
                                      .require_authentication = false,
@@ -34,29 +37,51 @@ Hammer::Hammer(const char *isa, const char *privilege_levels, const char *vector
                                      .support_abstract_csr_access = true,
                                      .support_haltgroups = true,
                                      .support_impebreak = true};
-  const char *log_path = nullptr;
+  const char *log_path = "ham.log";
   const char *dtb_file = nullptr;
   FILE *cmd_file = nullptr;
 
-  std::pair<reg_t, reg_t> initrd_bounds{0, 0};
-  const char *bootargs = nullptr;
-  bool real_time_clint = false;
-  bool misaligned = false;
+  // std::pair<reg_t, reg_t> initrd_bounds{0, 0};
+  // const char *bootargs = nullptr;
+  // bool real_time_clint = false;
+  // bool misaligned = false;
+  // bool explicit_hartids =false;
+
+  // reg_t trigger_count = 4;
+
+  // reg_t num_pmpregions = 16;
 
-  reg_t trigger_count = 4;
+  // reg_t pmpgranularity   = (1 << PMP_SHIFT);
 
-  reg_t num_pmpregions = 16;
+  // reg_t cache_blocksz = 64;
 
-  endianness_t endinaness = endianness_little;
+  // endianness_t endinaness = endianness_little;
+
+  // cfg_t cfg = cfg_t(initrd_bounds, bootargs, isa, privilege_levels, vector_arch, misaligned, endinaness, num_pmpregions, memory_layout,
+  //                   hart_ids, real_time_clint, trigger_count);
+
+  cfg_t cfg; // Spike Commit 6023896 revised the cfg_t class
+  // cfg.initrd_bounds    = initrd_bounds;
+  // cfg.bootargs         = bootargs;
+  cfg.isa              = isa;
+  cfg.priv             = privilege_levels;
+  // cfg.misaligned       = misaligned;
+  // cfg.endianness       = endinaness;
+  // cfg.pmpregions       = num_pmpregions;
+  // cfg.pmpgranularity   = pmpgranularity;
+  cfg.mem_layout       = memory_layout;
+  cfg.hartids          = hart_ids;
+  // cfg.explicit_hartids = explicit_hartids;
+  // cfg.real_time_clint  = real_time_clint;
+  // cfg.trigger_count    = trigger_count;
+  // cfg.cache_blocksz    = cache_blocksz;
 
-  cfg_t cfg = cfg_t(initrd_bounds, bootargs, isa, privilege_levels, vector_arch, misaligned, endinaness, num_pmpregions, memory_layout,
-                    hart_ids, real_time_clint, trigger_count);
 
   if (start_pc.has_value()) {
     cfg.start_pc = start_pc.value();
   }
 
-  std::vector<std::pair<reg_t, mem_t *>> mems = make_mems(memory_layout);
+  std::vector<std::pair<reg_t, abstract_mem_t*>> mems = make_mems(memory_layout);
 
   std::vector<std::string> htif_args;
   htif_args.push_back(target_binary);
@@ -64,16 +89,238 @@ Hammer::Hammer(const char *isa, const char *privilege_levels, const char *vector
   bool halted = false;
   bool dtb_enabled = true;
   bool socket_enabled = false;
+  std::optional<unsigned long long> instructions = std::nullopt;
 
-  simulator = new sim_t(&cfg, halted, mems, plugin_devices, htif_args, dm_config, log_path,
-                        dtb_enabled, dtb_file, socket_enabled, cmd_file);
+  // simulator = new sim_t(&cfg, halted, mems, plugin_devices, htif_args, dm_config, log_path,
+  //                       dtb_enabled, dtb_file, socket_enabled, cmd_file);
+  simulator = new sim_t(&cfg, halted, mems, plugin_device_factories, htif_args, dm_config, log_path,
+                        dtb_enabled, dtb_file, socket_enabled, cmd_file,instructions);
 
   // Initializes everything
+  bool enable_log=false;
+  bool enable_commitlog=true;
+  simulator->configure_log(enable_log,enable_commitlog);
   simulator->start();
 }
 
 Hammer::~Hammer() { delete simulator; }
 
+bool Hammer::get_log_commits_enabled(uint8_t hart_id){
+  processor_t *hart = simulator->get_core(hart_id);
+  return hart->get_log_commits_enabled();
+}
+
+// Instruction metadata
+insn_fetch_t Hammer::get_insn_fetch(uint8_t hart_id,reg_t pc){
+  processor_t *hart = simulator->get_core(hart_id);
+  mmu_t *mmu = hart->get_mmu();
+  insn_fetch_t fetch = mmu->load_insn(pc);
+  return fetch;
+}
+
+insn_t Hammer::get_insn(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn;
+}
+insn_bits_t Hammer::get_insn_hex(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.bits();
+}
+int Hammer::get_insn_length(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.length();
+}
+uint64_t Hammer::get_opcode(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.opcode();
+}
+
+uint64_t Hammer::get_rs1_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rs1();
+}
+uint64_t Hammer::get_rs2_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rs2();
+}
+uint64_t Hammer::get_rs3_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rs3();
+}
+uint64_t Hammer::get_rd_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rd();
+}
+uint64_t Hammer::get_csr_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.csr();
+}
+
+// RVC instructions metadata
+uint64_t Hammer::get_rvc_opcode(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rvc_opcode();
+}
+uint64_t Hammer::get_rvc_rs1_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rvc_rs1();
+}
+
+uint64_t Hammer::get_rvc_rs2_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rvc_rs2();
+}
+
+uint64_t Hammer::get_rvc_rd_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rvc_rd();
+}
+
+std::optional<reg_t> Hammer::get_memory_address(uint8_t hart_id) {
+  //If a load or store happened (not li or any immediate) , we can check the 
+  processor_t *hart = simulator->get_core(hart_id);
+  commit_log_reg_t reg_write =hart->get_state()->log_reg_write;
+  commit_log_mem_t mem_read = hart->get_state()->log_mem_read;
+  commit_log_mem_t mem_write = hart->get_state()->log_mem_write;
+  if (!mem_read.empty()) {
+    return std::get<0>(mem_read[0]); // addr from tuple<addr, value, size>
+  }
+  if (!mem_write.empty()) {
+    return std::get<0>(mem_write[0]);
+  }
+  return std::nullopt;
+}
+
+std::vector<std::pair<std::string, uint64_t>> Hammer::get_log_reg_writes(uint8_t hart_id){
+  processor_t *hart = simulator->get_core(hart_id);
+  commit_log_reg_t reg = hart->get_state()->log_reg_write;
+  int xlen = hart->get_state()->last_inst_xlen;
+  int flen = hart->get_state()->last_inst_flen;
+  bool show_vec = false;
+  
+  std::vector<std::pair<std::string, uint64_t>> result;
+  
+  for (auto item : reg) {
+    if (item.first == 0)
+      continue;
+
+    char prefix = ' ';
+    int size;
+    int rd = item.first >> 4;
+    bool is_vec = false;
+    bool is_vreg = false;
+    
+    // Determine register type and size (same logic as Spike)
+    switch (item.first & 0xf) {
+    case 0:
+      size = xlen;
+      prefix = 'x';
+      break;
+    case 1:
+      size = flen;
+      prefix = 'f';
+      break;
+    case 2:
+      size = hart->VU.get_vlen();
+      prefix = 'v';
+      is_vreg = true;
+      break;
+    case 3:
+      is_vec = true;
+      break;
+    case 4:
+      size = xlen;
+      prefix = 'c';
+      break;
+    default:
+      continue; // Skip unknown register types
+    }
+    // NOT RELEVANT FOR RV32IMC
+    if (!show_vec && (is_vreg || is_vec)) {
+        // some fprintf
+        show_vec = true;
+    }
+
+    if (!is_vec) {
+      // Create register name
+      std::string reg_name = std::string(1, prefix) + std::to_string(rd);
+      
+      // Extract the integer value directly from the register data
+      uint64_t int_value = 0;
+      if (size <= 64) {
+        // For 32-bit and 64-bit registers, use v[0]
+        int_value = item.second.v[0];
+        if (size == 32) {
+          // For 32-bit registers, mask to 32 bits
+          int_value &= 0xFFFFFFFF;
+        }
+      } else {
+        // For larger registers (like 128-bit), combine v[0] and v[1]
+        int_value = item.second.v[0] | (static_cast<uint64_t>(item.second.v[1]) << 32);
+      }
+      
+      // std::cout<<"Reg"<<" "<<reg_name<<" "<<"Value:"<<std::hex<<"0x"<<int_value<<std::dec<<std::endl;
+      result.emplace_back(reg_name, int_value);
+    }
+  }
+  
+  return result;
+}
+commit_log_mem_t Hammer::get_log_mem_reads(uint8_t hart_id){
+    commit_log_mem_t result;
+    processor_t *hart = simulator->get_core(hart_id);
+    commit_log_mem_t load = hart->get_state()->log_mem_read;
+    
+    if (!load.empty()) {
+        // std::cout << "=== MEMORY READS for PC: 0x" << std::hex << get_PC(hart_id) << std::dec << " ===" << std::endl;
+    }
+    
+    //address,data,size
+    for (auto item : load) {
+      // item is a tuple: <address, value, size>
+      reg_t addr = std::get<0>(item) & 0xFFFFFFFF;
+      uint64_t value = std::get<1>(item);
+      uint8_t size = std::get<2>(item);
+      
+      // std::cout<<std::hex<<"ADDR 0x"<<addr<<" value 0x"<<value<<" size "<<std::dec<<(int)size<<" bytes"<<std::endl;
+      // Add to result as a tuple
+      result.emplace_back(addr, value, size);
+    }
+    return result;
+
+}
+
+commit_log_mem_t Hammer::get_log_mem_writes(uint8_t hart_id){
+    commit_log_mem_t result;
+    processor_t *hart = simulator->get_core(hart_id);
+    commit_log_mem_t store = hart->get_state()->log_mem_write;
+    
+    // if (!store.empty()) {
+    //     std::cout << "=== MEMORY WRITES ===" << std::endl;
+    // }
+    
+    //address,data,size
+    for (auto item : store) {
+      // item is a tuple: <address, value, size>
+      reg_t addr = std::get<0>(item) & 0xFFFFFFFF;
+      uint64_t value = std::get<1>(item);
+      uint8_t size = std::get<2>(item);
+      
+      // std::cout<<std::hex<<"WRITE ADDR 0x"<<addr<<" value 0x"<<value<<" size "<<std::dec<<(int)size<<" bytes"<<std::endl;
+      // Add to result as a tuple
+      result.emplace_back(addr, value, size);
+    }
+    return result;
+}
+
+std::optional<uint64_t> Hammer::get_memory_read_data(uint8_t hart_id) {
+  processor_t *hart = simulator->get_core(hart_id);
+  auto& mem_read = hart->get_state()->log_mem_read;
+  if (!mem_read.empty()) {
+    return std::get<1>(mem_read[0]); // value from tuple
+  }
+  return std::nullopt;
+}
+//tuple has <addr,val,hexe>
+std::optional<uint64_t> Hammer::get_memory_write_data(uint8_t hart_id) {
+  processor_t *hart = simulator->get_core(hart_id);
+  auto& mem_write = hart->get_state()->log_mem_write;
+  if (!mem_write.empty()) {
+    return std::get<1>(mem_write[0]); // value from tuple
+  }
+  return std::nullopt;
+}
+
+
+
+
 reg_t Hammer::get_gpr(uint8_t hart_id, uint8_t gpr_id) {
   assert(gpr_id < NXPR);
 
@@ -106,7 +353,7 @@ reg_t Hammer::get_PC(uint8_t hart_id) {
   processor_t *hart = simulator->get_core(hart_id);
   state_t *hart_state = hart->get_state();
 
-  return hart_state->pc;
+  return hart_state->pc  & 0xFFFFFFFF;
 }
 
 void Hammer::set_PC(uint8_t hart_id, reg_t new_pc_value) {
@@ -116,9 +363,14 @@ void Hammer::set_PC(uint8_t hart_id, reg_t new_pc_value) {
   hart_state->pc = new_pc_value;
 }
 
-reg_t Hammer::get_csr(uint8_t hart_id, uint32_t csr_id) {
+std::optional<reg_t> Hammer::get_csr(uint8_t hart_id, uint32_t csr_id) {
   processor_t *hart = simulator->get_core(hart_id);
-  return hart->get_csr(csr_id);
+  try {
+    return hart->get_csr(csr_id);
+  } catch (...) {
+    // Return nullopt for invalid/non-existent CSRs
+    return std::nullopt;
+  }
 }
 
 void Hammer::single_step(uint8_t hart_id) {
diff --git a/hammer.h b/hammer.h
index 654a267..2f23cfc 100644
--- a/hammer.h
+++ b/hammer.h
@@ -3,8 +3,11 @@
 // SPDX-License-Identifier: Apache-2.0
 
 #pragma once
-
+// #define _GNU_SOURCE        // redundant but harmless alongside the -D flag
+#include <sys/syscall.h>   // brings in SYS_futex on glibc
+// #include <linux/futex.h>   // (optional) gives FUTEX_* enums if you ever need them 
 #include "hammer_enums.h"
+#include "riscv/devices.h"        // device_factory_t
 #include "riscv/mmu.h"
 #include "riscv/sim.h"
 
@@ -17,6 +20,36 @@ class Hammer {
          const std::string target_binary, const std::optional<uint64_t> start_pc = std::nullopt);
   ~Hammer();
 
+  bool get_log_commits_enabled(uint8_t hart_id);
+
+  insn_t get_insn(uint8_t hart_id,reg_t pc);
+  int get_insn_length(uint8_t hart_id,reg_t pc);
+  insn_bits_t get_insn_hex(uint8_t hart_id,reg_t pc);
+  u_int64_t get_opcode(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rs1_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rs2_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rs3_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rd_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_csr_addr(uint8_t hart_id,reg_t pc);
+  
+  //RVC instructions
+  u_int64_t get_rvc_opcode(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rvc_rs1_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rvc_rs2_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rvc_rd_addr(uint8_t hart_id,reg_t pc);
+  
+  std::optional<reg_t> get_memory_address(uint8_t hart_id);
+  std::optional<uint64_t> get_memory_read_data(uint8_t hart_id);
+  std::optional<uint64_t> get_memory_write_data(uint8_t hart_id);
+  // void dump(uint8_t hart_id);
+  
+  // Detailed register write logging (like Spike's commit log)
+  std::vector<std::pair<std::string, uint64_t>> get_log_reg_writes(uint8_t hart_id);
+  commit_log_mem_t get_log_mem_reads(uint8_t hart_id);
+  commit_log_mem_t get_log_mem_writes(uint8_t hart_id);
+  
+  
+  
   reg_t get_gpr(uint8_t hart_id, uint8_t gpr_id);
   void set_gpr(uint8_t hart_id, uint8_t gpr_id, reg_t new_gpr_value);
 
@@ -25,7 +58,7 @@ class Hammer {
   reg_t get_PC(uint8_t hart_id);
   void set_PC(uint8_t hart_id, reg_t new_pc_value);
 
-  reg_t get_csr(uint8_t hart_id, uint32_t csr_id);
+  std::optional<reg_t> get_csr(uint8_t hart_id, uint32_t csr_id);
 
   void single_step(uint8_t hart_id);
 
@@ -71,4 +104,5 @@ class Hammer {
 
  private:
   sim_t *simulator;
+  insn_fetch_t get_insn_fetch(uint8_t hart_id,reg_t pc);
 };
diff --git a/hammer_example.py b/hammer_example.py
new file mode 100644
index 0000000..7bbdcc8
--- /dev/null
+++ b/hammer_example.py
@@ -0,0 +1,96 @@
+#!/usr/bin/env python3
+"""
+Quick sanity script for the Hammer ⇆ Spike wrapper.
+
+Usage:
+    python hammer_example.py path/to/program.elf
+
+Make sure:
+  * $LD_LIBRARY_PATH contains <SPIKE_PREFIX>/lib
+  * The `hammer` extension (built with Meson) is discoverable in PYTHONPATH or installed.
+"""
+
+import sys
+import hammer
+
+def main():
+    if len(sys.argv) < 2:
+        print("Usage: python hammer_example.py <prog.elf>")
+        sys.exit(1)
+
+    elf = sys.argv[1]
+    print(f"Loading ELF: {elf}")
+
+    mem_cfg = hammer.mem_cfg_t(0x80000000, 256 * 1024 * 1024)
+
+    sim = hammer.Hammer(
+        "RV32IMC",          # arg0: isa
+        "msu",              # arg1: privilege_levels  
+        "",                 # arg2: vector_arch
+        [0],                # arg3: hart_ids
+        [mem_cfg],          # arg4: memory_layout (sequence of mem_cfg_t)
+        elf,                # arg5: target_binary
+        None                # arg6: start_pc (optional)
+    )
+
+    print("Initial PC:", hex(sim.get_PC(0)))
+
+    # Step through first 10 instructions
+    for i in range(300):
+        hart=0
+
+        pc  = sim.get_PC(0)
+        insn_hex = sim.get_insn_hex(0, pc)
+        rs1 = sim.get_rs1_addr(0, pc)
+        rs2 = sim.get_rs2_addr(0, pc)
+        rs3 = sim.get_rs3_addr(0, pc)
+        rd  = sim.get_rd_addr(0, pc)
+        csr = sim.get_csr_addr(0, pc)
+        csr_val = sim.get_csr(0, csr)
+        length = sim.get_insn_length(0, pc)
+        enable = sim.get_log_commits_enabled(0)
+        # Handle optional CSR value (None if invalid CSR)
+        if csr_val is None:
+            csr_val = "N/A"
+
+        sim.single_step(0)
+        
+
+        a0  = sim.get_gpr(0, 10)   # x10/a0
+        val_a = sim.get_memory_at_VA(0, 0x8000bc48, 4, 1)
+        val = 0
+        if val_a is not None:
+            for byte_value in val_a:
+                val |= (byte_value << (val_a.index(byte_value) * 8))
+        
+        print(f"Step {i+1:02d}: pc={pc:#x} insn={insn_hex:#x}")
+        reg_writes=sim.get_log_reg_writes(0)  # Dump the state of hart 0
+        if reg_writes:
+            print("=== REGISTER WRITES ===")
+            for reg, value in reg_writes:
+                print(f"WRITE REG: {reg}, VALUE: {value:#x}")
+
+        mem_reads=sim.get_log_mem_reads(0)
+        if mem_reads and len(mem_reads) > 4:
+            print("=== MEMORY READS ===")
+            for addr, value, size in mem_reads :
+                print(f"READ ADDRESS: {addr:#x}, VALUE: {value:#x}, SIZE: {size} bytes")
+                break
+        mem_writes=sim.get_log_mem_writes(0)
+        if mem_writes:
+            print("=== MEMORY WRITES ===")
+            for addr, value, size in mem_writes:
+                print(f"WRITE ADDRESS: {addr:#x}, VALUE: {value:#x}, SIZE: {size} bytes")
+        memory_contents = sim.get_memory_at_VA(0, 0x80002000, 4, 1)
+        value_at_address = 0
+        x = 0
+        if memory_contents is not None:
+            for byte_value in memory_contents:
+                value_at_address |= (byte_value << (x * 8))
+                x += 1
+        if value_at_address==1:
+            print("Reached target memory location, stopping simulation.")
+            break
+
+if __name__ == "__main__":
+    main()
diff --git a/hammer_pybind.cpp b/hammer_pybind.cpp
index 495cb9d..95fc107 100644
--- a/hammer_pybind.cpp
+++ b/hammer_pybind.cpp
@@ -19,6 +19,32 @@ PYBIND11_MODULE(hammer, m) {
                           std::vector<mem_cfg_t>, const std::string,
                           const std::optional<uint64_t>>())
       .def("hello_world", &Hammer::hello_world)
+      .def("get_log_commits_enabled",&Hammer::get_log_commits_enabled)
+
+      .def("get_insn_hex",&Hammer::get_insn_hex)
+      .def("get_insn",&Hammer::get_insn)
+      .def("get_insn_length",&Hammer::get_insn_length)
+      .def("get_opcode",&Hammer::get_opcode)
+      .def("get_rs1_addr",&Hammer::get_rs1_addr)
+      .def("get_rs2_addr",&Hammer::get_rs2_addr)
+      .def("get_rs3_addr",&Hammer::get_rs3_addr)
+      .def("get_rd_addr",&Hammer::get_rd_addr)
+      .def("get_csr_addr",&Hammer::get_csr_addr)
+
+      //RVC
+      .def("get_rvc_opcode",&Hammer::get_rvc_opcode)
+      .def("get_rvc_rs1_addr",&Hammer::get_rvc_rs1_addr)
+      .def("get_rvc_rs2_addr",&Hammer::get_rvc_rs2_addr)
+      .def("get_rvc_rd_addr",&Hammer::get_rvc_rd_addr)
+
+      .def("get_memory_address",&Hammer::get_memory_address)
+      .def("get_memory_read_data",&Hammer::get_memory_read_data)
+      .def("get_memory_write_data",&Hammer::get_memory_write_data)
+      .def("get_log_reg_writes",&Hammer::get_log_reg_writes)
+      .def("get_log_mem_reads",&Hammer::get_log_mem_reads)
+      .def("get_log_mem_writes",&Hammer::get_log_mem_writes)
+
+      
       .def("get_gpr", &Hammer::get_gpr)
       .def("set_gpr", &Hammer::set_gpr)
       .def("get_fpr", &Hammer::get_fpr)
diff --git a/hammer_run.py b/hammer_run.py
new file mode 100644
index 0000000..d71d46a
--- /dev/null
+++ b/hammer_run.py
@@ -0,0 +1,20 @@
+import hammer, pathlib, sys
+
+# print(dir(hammer))
+# elf = sys.argv[1]
+elf = "/home/nitin/cocotb_simulation/top_tracing_simulation/ibex_arithmetic_basic_test_0.o"
+
+# Build one mem_cfg_t object – (base, size) just like the C++ struct
+mem_cfg = hammer.mem_cfg_t(0x8000_0000, 256 * 1024 * 1024)   # 256 MiB DRAM
+
+# print(dir(hammer.Hammer))
+
+#               0           1           2       3       4           5     [6]
+sim = hammer.Hammer("RV32IMC", "msu",   "",   [0],  [mem_cfg],elf,None) 
+#                ↑          ↑           ↑     ↑       ↑           ↑     ↑
+#                isa   privilege_levels  vlen hartIDs  mem_layout  ELF  (start_pc optional)
+
+# print("Initial PC:", hex(sim.get_PC(0)))
+# for i in range(10):
+#     sim.single_step(0)
+#     print(f"{i+1:02}: pc={hex(sim.get_PC(0))}")
diff --git a/meson.build b/meson.build
index fd21cba..6b0d603 100644
--- a/meson.build
+++ b/meson.build
@@ -10,6 +10,13 @@ project('hammer lib', 'cpp',
           'default_library=static'
           ]
         )
+add_project_arguments(
+  ['-D_GNU_SOURCE',
+   '-Wno-error=unused-variable',
+   '-Wno-error=unused-parameter'],
+  language: 'cpp')
+# Added additionally 
+
 
 spike_install_dir = get_option('spike_install_dir')
 
@@ -86,5 +93,3 @@ hammer_pylib = python3_instance.extension_module('hammer',
 
 install_headers('hammer.h', 'hammer_enums.h')
 
-subdir('tests')
-subdir('pytests')
diff --git a/native-file.txt b/native-file.txt
index b0d620f..635f844 100644
--- a/native-file.txt
+++ b/native-file.txt
@@ -4,6 +4,11 @@
 
 # GCC has trouble with some of the compiler flags so use clang instead.
 
+#[binaries]
+#cc = 'clang'
+#cpp = 'clang++'
 [binaries]
-cc = 'clang'
-cpp = 'clang++'
+c   = '/usr/bin/gcc'
+cpp = '/usr/bin/g++'
+ar  = '/usr/bin/ar'
+strip = '/usr/bin/strip'
\ No newline at end of file
diff --git a/tests/test000.cpp b/tests/test000.cpp
index 2050763..e82f69c 100644
--- a/tests/test000.cpp
+++ b/tests/test000.cpp
@@ -69,7 +69,12 @@ int main(int argc, char *argv[]) {
     hammer.single_step(0);
   }
 
-  reg_t current_mstatus = hammer.get_csr(0, MSTATUS_CSR);
+  auto mstatus_opt = hammer.get_csr(0, MSTATUS_CSR);
+  if (!mstatus_opt.has_value()) {
+    printf("Failed to read mstatus CSR\n");
+    exit(1);
+  }
+  reg_t current_mstatus = mstatus_opt.value();
   if (current_mstatus != 0x8000000a00002600) {
     printf("Unexpected mstatus: 0x%" PRIx64 "\n", current_mstatus);
     exit(1);
