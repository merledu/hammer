diff --git a/.gitignore b/.gitignore
index dd96872..6152bc0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -3,3 +3,5 @@
 # SPDX-License-Identifier: Apache-2.0
 
 .vscode
+
+ham.log
\ No newline at end of file
diff --git a/HAMMER.md b/HAMMER.md
new file mode 100644
index 0000000..3fcb789
--- /dev/null
+++ b/HAMMER.md
@@ -0,0 +1,324 @@
+# Documentation on Hammer & Modifying it for Our Use Case
+
+**Date:** July 31, 2025
+
+**Latest Hammer Commit:** 6d9fac96407149a1a533cdd3f63f6bbd96614ffa
+
+Hammer is an infrastructure to drive Spike (the RISC-V ISA Simulator) in co-simulation mode, designed by Rivos. It provides both C++ and Python interfaces to interact with Spike, enabling detailed instruction-level simulation, tracing, and analysis for RISC-V software and hardware development. Hammer is especially useful for co-simulation, debugging, and automated test environments.
+
+The source code is available here: [https://github.com/rivosinc/hammer](https://github.com/rivosinc/hammer)
+
+Hammer leverages `pybind` to provide a Python interface, using Spike’s executables and shared libraries to enable seamless integration between Python and C++. This allows users to script, automate, and analyze RISC-V simulation runs directly from Python, while still having access to the full power of Spike's C++ backend.
+
+`meson` is the build infrastructure used to build the Hammer source code and execute it. This ensures a modern, fast, and reproducible build process.
+
+The main sections in this repo are:
+
+- `hammer.h`  — Contains the Hammer class definition and API
+- `hammer.cpp` — Implementation of the Hammer class and core logic
+- `hammer_enums.h` — Enumerations for register types, privilege levels, etc.
+- `hammer_pybind.cpp` — Python bindings using pybind11
+
+---
+
+### Features
+
+- Single-step and batch instruction execution
+- Python and C++ APIs for scripting and automation
+- Support for custom extensions and modifications
+
+---
+
+### Build & Installation
+
+Hammer uses `meson` as its build infrastructure.
+The build steps can be found at the Hammer repository.
+Refer to it [here](https://github.com/rivosinc/hammer/blob/main/README.md)
+
+### Command to Run Tests
+
+To run the tests:
+
+```sh
+meson test -C builddir
+```
+
+This command compiles the test input files into ELF binaries using a RISC-V toolchain and executes them through the Meson test framework.
+
+## Common Build Errors
+
+## NOTE
+
+The command `meson test -C builddir` has **not been successfully tested** in this environment.
+
+> **This is because it requires:**
+>
+> - A RISC-V GCC toolchain that supports the `rv64gcv` ISA (including vector instructions).
+> - Properly formatted linker scripts that avoid using unsupported syntax (e.g., `#` for comments).
+>
+> Without these prerequisites, test compilation and execution will fail due to assembler or linker errors.
+
+---
+
+## Usage
+
+The current functionalities exposed through the interface include:
+
+- Instantiating a Hammer object in `Python` which initializes the Spike simulator and preloads the ELF File.
+
+  ```python
+  import builddir.hammer as pyhammer
+  hammer = pyhammer.Hammer("RV64GCV", "MSU", "vlen:512,elen:64", hart_ids, [mem_layout], elf_name, None)
+  ```
+
+  - Another example in `Python`:
+
+  ```python
+  import builddir.hammer as pyhammer
+  mem_cfg = pyhammer.mem_cfg_t(pyhammer.DramBase, 256 * 1024 * 1024)
+  hammer = pyhammer.Hammer("RV32IMC", "msu", "", hart_ids, [mem_cfg], target_binary, None)
+  ```
+- Instantiating a Hammer object in `C++` which initializes the Spike simulator and preloads the ELF File.
+
+  ```cpp
+  Hammer(const char *isa, const char *privilege_levels, const char *vector_arch,
+         std::vector<size_t> hart_ids, std::vector<mem_cfg_t> memory_layout,
+         const std::string target_binary, const std::optional<uint64_t> start_pc = std::nullopt)
+  ```
+
+  - Example snippet in `C++`:
+
+  ```cpp
+  std::vector<mem_cfg_t> memory_layout;
+  // This is what Spike sets it to
+  memory_layout.push_back(mem_cfg_t(reg_t(DRAM_BASE), reg_t(2048) << 20));
+
+  std::vector<size_t> hart_ids{0};
+  Hammer hammer = Hammer("RV64GCV", "MSU", "vlen:512,elen:32", hart_ids, memory_layout,
+                         target_binary, std::nullopt);
+  ```
+
+Some more example snippets in `C++` can be found in `hammer/tests` and `hammer/pytests` for `Python`.
+
+### Exposed Functionalities
+
+- **get_gpr / set_gpr**: Read or write the value of a general-purpose register (GPR) for a specific hardware thread (hart).
+- **get_fpr**: Retrieve the value of a floating-point register (FPR) for a given hart.
+- **get_PC / set_PC**: Get or set the program counter (PC) for a specified hart.
+  **NOTE:** The `get_PC` returns pc address which points to the next instruction to be executed, not the current instruction that has been executed.
+- **get_csr**: Access the value of a control and status register (CSR) for a particular hart.
+- **single_step**: Execute a single instruction on the specified hart, advancing its state by one step.
+- **get_flen**: Obtain the floating-point register width (FLEN) for a hart.
+- **get_vlen / get_elen**: Retrieve the vector register length (VLEN) and element length (ELEN) for a hart.
+- **get_vector_reg**: Fetch the contents of a vector register for a given hart.
+- **get_memory_at_VA**: Read a specified number of bytes from virtual memory at a given address for a hart, returning the data as a vector of the requested type.
+- **set_memory_at_VA**: Write a vector of values to virtual memory at a specified address for a hart, storing the data as the given type.
+
+### Additional Python Interface
+
+  The Hammer Python module, exposed via `pybind11`, also provides:
+
+- **Enums for Platform and CSR Registers**:The module exposes the `PlatformDefines` and `CsrDefines` enums, allowing you to refer to platform constants and a comprehensive set of RISC-V Control and Status Register (CSR) identifiers directly from Python. For example:
+
+  ```python
+  from builddir import hammer as pyhammer
+  csr_val = pyhammer.CsrDefines.MSTATUS_CSR
+  ```
+- **Memory Configuration and Memory Objects**:The classes `mem_cfg_t` and `mem_t` are available in Python for configuring memory regions and representing memory, respectively.
+
+  ```python
+  mem_cfg = pyhammer.mem_cfg_t(base_addr, size)
+  memory = pyhammer.mem_t(size)
+  ```
+- **hello_world**:
+  A simple method for testing the Python binding, which returns a greeting string from the Hammer backend.
+
+  ```python
+  print(hammer.hello_world())
+  ```
+
+## Modifying Hammer for Our Use Case
+
+With recent updates in Spike, several internal functions have changed their interface. As a result, our wrapper code around Spike had to be updated to reflect these **API changes**. This ensures compatibility and proper exposure of required functionality to Hammer.
+
+The curent changes are done to Hammer with Spike commit `113ef64f6724b769ef9298e6a4a9802f7671021f` (https://github.com/riscv-software-src/riscv-isa-sim/commit/113ef64f6724b769ef9298e6a4a9802f7671021f) as of August 1, 2025.
+
+With the recent updates in Spike, Hammer has been modified to accommodate these changes.
+
+# Modifications:
+
+## 1. What’s Added in This Fork ?
+
+| Area                                | Change                                                                                                                                                       | Why it matters                                                                                                                                                                                                                                                                                               |
+| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
+| **Instruction introspection** | `get_insn*` helpers (word, hex, length,string) & `get_opcode`, `get_rs1_addr`, `get_rs2_addr`, `get_rs3_addr`, `get_rd_addr`, `get_csr_addr`  | To get more information about the instruction decoded                                                                                                                                                                                                                                                        |
+| **RVC support**               | `get_rvc_opcode`, `get_rvc_rs*`, `get_rvc_rd_addr`                                                                                                     | Same as above but for 16‑bit compressed instructions                                                                                                                                                                                                                                                        |
+| **Commit‑log access**        | `get_log_commits_enabled`, `get_log_reg_writes`, `get_log_mem_reads`, `get_log_mem_writes`                                                           | `<ul><li>`Enables spike to log the instructions `</li><li>`Access register logs to extract register write data and export to interface `</li><li>`Access memory read and write logs to extract memory accesses and export to interface `</li><li>`Enable debugging and trace analysis `</li></ul>` |
+| **CSR access**                | `get_csr` now returns `std::optional<reg_t>`                                                                                                             | `<ul><li>`Avoids crashes on unimplemented CSRs instead of throwing access errors `</li><li>`Flexibility from interface side to check if a CSR instruction was executed or not `</li><li>`Provides a consistent interface for accessing CSR values `</li></ul>`                                       |
+| **Helper**                    | private `get_insn_fetch()`                                                                                                                                 | Centralises MMU fetch so helpers stay small                                                                                                                                                                                                                                                                  |
+| **Default logging**           | Spike log path now defaults to**`ham.log`** (Can be customised and compiled)                                                                               | Easy side‑by‑side core vs. cosim inspection                                                                                                                                                                                                                                                              |
+| **Build system**              | *Meson* tweaks: `-D_GNU_SOURCE`, relaxed unused‑* warnings, removed hard‑wired test dirs                                                               | Builds cleanly with recent Clang/GCC and Spike headers                                                                                                                                                                                                                                                       |
+| **Examples**                  | `hammer_example.py`, `hammer_run.py`                                                                                                                     | End‑to‑end demo: load ELF, single‑step, print decoded fields                                                                                                                                                                                                                                              |
+
+Files touched:
+
+```
+README.md            (this file)
+hammer.h             hammer.cpp
+hammer_pybind.cpp    meson.build
+native-file.txt      hammer_example.py
+hammer_run.py        tests/test000.cpp
+ham.log              (new default log)
+```
+
+**NOTE:** Since the Spike's API has changed, the existing tests in `tests/*` and `pytests/*` may need to be updated to reflect these changes. But to test the updated API , you can run `hammer_example.py` or `hammer_run.py` to see the new features in action.
+
+---
+
+## 2 · Extended C++ API
+
+```cpp
+ // New public methods on class Hammer
+bool                         get_log_commits_enabled(uint8_t hart);
+insn_t                       get_insn(uint8_t hart, reg_t pc);
+int                          get_insn_length(uint8_t hart, reg_t pc);
+uint64_t                     get_insn_hex(uint8_t hart, reg_t pc);
+std::string 		     get_insn_string(uint8_t hart_id,reg_t pc);
+
+uint64_t                     get_opcode(uint8_t hart, reg_t pc);
+uint64_t                     get_rs1_addr(uint8_t hart, reg_t pc);
+uint64_t                     get_rs2_addr(uint8_t hart, reg_t pc);
+uint64_t                     get_rs3_addr(uint8_t hart, reg_t pc);
+uint64_t                     get_rd_addr(uint8_t hart, reg_t pc);
+uint64_t                     get_csr_addr(uint8_t hart, reg_t pc);
+
+uint64_t                     get_rvc_opcode(uint8_t hart, reg_t pc);
+uint64_t                     get_rvc_rs1_addr(uint8_t hart, reg_t pc);
+uint64_t                     get_rvc_rs2_addr(uint8_t hart, reg_t pc);
+uint64_t                     get_rvc_rd_addr(uint8_t hart, reg_t pc);
+
+std::vector<std::pair<std::string,uint64_t>> get_log_reg_writes(uint8_t hart); // returns [register string name,data]
+commit_log_mem_t             get_log_mem_reads(uint8_t hart); // returns vector of [addr,data,size]
+commit_log_mem_t             get_log_mem_writes(uint8_t hart); //returns vector of [addr,data,size]
+std::optional<reg_t>         get_csr(uint8_t hart, uint32_t csr_id);
+```
+
+ **Observations:** When using `get_log_mem_reads()` , the returned `commit_log_mem_t` length is atleast 4 in all instruction executions. The address it read in my case was the address next to `<kernel_stack_end>`. The reason for this is not very clear, but it seems to be a quirk of the Spike simulator. But if the length is more than 4 , the first instructions that it reads will be the actual memory read instruction, so you can take all the vector pairs except the last four in the returned vector.
+
+```python
+        mem_reads=sim.get_log_mem_reads(0)
+        if mem_reads and len(mem_reads) > 4:
+            print("=== MEMORY READS ===")
+            for addr, value, size in mem_reads :
+                addr &= 0xFFFFFFFF  # Mask to 32 bits
+                print(f"READ ADDRESS: {addr:#x}, VALUE: {value:#x}, SIZE: {size} bytes")
+                break
+```
+
+---
+
+## 3 · Python Bindings
+
+All new C++ methods are exported 1‑to‑1 via Pybind11.
+
+```python
+import hammer, pathlib
+
+elf = pathlib.Path("./ibex_load_instr_test_0.o")
+mem = hammer.mem_cfg_t(0x8000_0000, 256 * 1024 * 1024)
+
+sim = hammer.Hammer("RV32IMC", "msu", "", [0], [mem], str(elf), None)
+
+for _ in range(10):
+    pc  = sim.get_PC(0)
+    raw = sim.get_insn_hex(0, pc)
+    opc = sim.get_opcode(0, pc)
+    print(f"PC={pc:08x}  insn={raw:08x}  opcode={opc:03x}")
+    sim.single_step(0)
+```
+
+---
+
+## 4 · Building
+
+Edit ~/.bashrc and add
+
+```bash
+export SPIKE_HOME=$HOME/hammer-deps/spike-install      # or whatever you used
+```
+
+to set the Spike install directory globally.
+
+Then run the following commands in your terminal
+
+### 1. Build and install Spike (exact commit below)
+
+Skip this step if you edited `~/.bashrc` to set `SPIKE_HOME`.
+
+```bash
+export SPIKE_HOME=$HOME/hammer-deps/spike-install      # or whatever you used
+
+git clone https://github.com/riscv-software-src/riscv-isa-sim
+cd riscv-isa-sim && git checkout 113ef64f
+mkdir build && cd build && ../configure --prefix=$SPIKE_HOME 
+make -j$(nproc)
+make install
+```
+
+### 2. Build Hammer
+
+```bash
+python3 -m pip install pybind11
+meson setup builddir   --buildtype=release -Dspike_install_dir=$SPIKE_HOME
+meson compile -C builddir
+```
+
+> **Tip:** `LD_LIBRARY_PATH=$SPIKE_HOME/lib` must include the Spike libraries when you import `hammer` in Python.
+
+Add the following to your `~/.bashrc` to set the `LD_LIBRARY_PATH` and `builddir/` into PYTHONPATH globally:
+
+```bash
+export LD_LIBRARY_PATH=$SPIKE_HOME/lib:$LD_LIBRARY_PATH
+export PYTHONPATH=path-to-hammer/builddir:$PYTHONPATH
+```
+
+Then run:
+
+```bash
+source ~/.bashrc
+```
+
+**Note:** If using 2 or more virtual environments(to build Hammer and to import Hammer elsewhere), make sure they both run on same Python version and in the virtual environment where you want to import Hammer, run the following command:
+
+```bash
+# Create a virtual environment in the directory where you want to import Hammer
+python3 -m venv .venv
+
+# Add Hammer to PYTHONPATH automatically when activating
+echo 'export PYTHONPATH=path-to-hammer/hammer/builddir:$PYTHONPATH' > .venv/bin/activate.d/hammer.sh
+chmod +x .venv/bin/activate.d/hammer.sh
+
+source .venv/bin/activate
+```
+
+Now you can import `hammer` in Python and use it as described in the examples above.
+
+---
+
+## 5 · Running the Example
+
+```bash
+python3 hammer_example.py ./ibex_load_instr_test_0.o
+```
+
+Expect a short trace of `PC`, raw instruction, decoded opcode, plus an updated `ham.log` commit log.
+
+---
+
+## 6 · Known Limitations
+
+* Only tested on **RV32IMC**; RV64 helpers compile but lack CI.
+* Memory helpers show the last address/data pair seen by the MMU this cycle; concurrent load‑store contention on multi‑harts is **not** exposed yet.
+* CSR access returns `None` if Spike was compiled without that CSR – handle it.
+
+---
diff --git a/README.md b/README.md
index a47d0ec..52804d4 100644
--- a/README.md
+++ b/README.md
@@ -19,6 +19,8 @@ Infrastructure to drive Spike (RISC-V ISA Simulator) in cosim mode. Hammer provi
 python3 -m pip install pybind11
 ```
 * Libraries and headers from Spike
+* Hammer was last tested with Spike commit `3349dc51`. Checkout this commit in
+  Spike before building.
 
 In the Spike repo run:
 
@@ -30,7 +32,7 @@ make
 make install
 ```
 
-The SHA of the last tested Spike version is included in the name of the patch file.
+Hammer was last tested with Spike commit `3349dc51`.
 
 ## Building Hammer and Running Tests
 
diff --git a/fork_diff.patch b/fork_diff.patch
new file mode 100644
index 0000000..081d485
--- /dev/null
+++ b/fork_diff.patch
@@ -0,0 +1,289 @@
+diff --git a/.gitignore b/.gitignore
+index dd96872..6152bc0 100644
+--- a/.gitignore
++++ b/.gitignore
+@@ -3,3 +3,5 @@
+ # SPDX-License-Identifier: Apache-2.0
+ 
+ .vscode
++
++ham.log
+\ No newline at end of file
+diff --git a/HAMMER.md b/HAMMER.md
+new file mode 100644
+index 0000000..3fcb789
+--- /dev/null
++++ b/HAMMER.md
+@@ -0,0 +1,324 @@
++# Documentation on Hammer & Modifying it for Our Use Case
++
++**Date:** July 31, 2025
++
++**Latest Hammer Commit:** 6d9fac96407149a1a533cdd3f63f6bbd96614ffa
++
++Hammer is an infrastructure to drive Spike (the RISC-V ISA Simulator) in co-simulation mode, designed by Rivos. It provides both C++ and Python interfaces to interact with Spike, enabling detailed instruction-level simulation, tracing, and analysis for RISC-V software and hardware development. Hammer is especially useful for co-simulation, debugging, and automated test environments.
++
++The source code is available here: [https://github.com/rivosinc/hammer](https://github.com/rivosinc/hammer)
++
++Hammer leverages `pybind` to provide a Python interface, using Spike’s executables and shared libraries to enable seamless integration between Python and C++. This allows users to script, automate, and analyze RISC-V simulation runs directly from Python, while still having access to the full power of Spike's C++ backend.
++
++`meson` is the build infrastructure used to build the Hammer source code and execute it. This ensures a modern, fast, and reproducible build process.
++
++The main sections in this repo are:
++
++- `hammer.h`  — Contains the Hammer class definition and API
++- `hammer.cpp` — Implementation of the Hammer class and core logic
++- `hammer_enums.h` — Enumerations for register types, privilege levels, etc.
++- `hammer_pybind.cpp` — Python bindings using pybind11
++
++---
++
++### Features
++
++- Single-step and batch instruction execution
++- Python and C++ APIs for scripting and automation
++- Support for custom extensions and modifications
++
++---
++
++### Build & Installation
++
++Hammer uses `meson` as its build infrastructure.
++The build steps can be found at the Hammer repository.
++Refer to it [here](https://github.com/rivosinc/hammer/blob/main/README.md)
++
++### Command to Run Tests
++
++To run the tests:
++
++```sh
++meson test -C builddir
++```
++
++This command compiles the test input files into ELF binaries using a RISC-V toolchain and executes them through the Meson test framework.
++
++## Common Build Errors
++
++## NOTE
++
++The command `meson test -C builddir` has **not been successfully tested** in this environment.
++
++> **This is because it requires:**
++>
++> - A RISC-V GCC toolchain that supports the `rv64gcv` ISA (including vector instructions).
++> - Properly formatted linker scripts that avoid using unsupported syntax (e.g., `#` for comments).
++>
++> Without these prerequisites, test compilation and execution will fail due to assembler or linker errors.
++
++---
++
++## Usage
++
++The current functionalities exposed through the interface include:
++
++- Instantiating a Hammer object in `Python` which initializes the Spike simulator and preloads the ELF File.
++
++  ```python
++  import builddir.hammer as pyhammer
++  hammer = pyhammer.Hammer("RV64GCV", "MSU", "vlen:512,elen:64", hart_ids, [mem_layout], elf_name, None)
++  ```
++
++  - Another example in `Python`:
++
++  ```python
++  import builddir.hammer as pyhammer
++  mem_cfg = pyhammer.mem_cfg_t(pyhammer.DramBase, 256 * 1024 * 1024)
++  hammer = pyhammer.Hammer("RV32IMC", "msu", "", hart_ids, [mem_cfg], target_binary, None)
++  ```
++- Instantiating a Hammer object in `C++` which initializes the Spike simulator and preloads the ELF File.
++
++  ```cpp
++  Hammer(const char *isa, const char *privilege_levels, const char *vector_arch,
++         std::vector<size_t> hart_ids, std::vector<mem_cfg_t> memory_layout,
++         const std::string target_binary, const std::optional<uint64_t> start_pc = std::nullopt)
++  ```
++
++  - Example snippet in `C++`:
++
++  ```cpp
++  std::vector<mem_cfg_t> memory_layout;
++  // This is what Spike sets it to
++  memory_layout.push_back(mem_cfg_t(reg_t(DRAM_BASE), reg_t(2048) << 20));
++
++  std::vector<size_t> hart_ids{0};
++  Hammer hammer = Hammer("RV64GCV", "MSU", "vlen:512,elen:32", hart_ids, memory_layout,
++                         target_binary, std::nullopt);
++  ```
++
++Some more example snippets in `C++` can be found in `hammer/tests` and `hammer/pytests` for `Python`.
++
++### Exposed Functionalities
++
++- **get_gpr / set_gpr**: Read or write the value of a general-purpose register (GPR) for a specific hardware thread (hart).
++- **get_fpr**: Retrieve the value of a floating-point register (FPR) for a given hart.
++- **get_PC / set_PC**: Get or set the program counter (PC) for a specified hart.
++  **NOTE:** The `get_PC` returns pc address which points to the next instruction to be executed, not the current instruction that has been executed.
++- **get_csr**: Access the value of a control and status register (CSR) for a particular hart.
++- **single_step**: Execute a single instruction on the specified hart, advancing its state by one step.
++- **get_flen**: Obtain the floating-point register width (FLEN) for a hart.
++- **get_vlen / get_elen**: Retrieve the vector register length (VLEN) and element length (ELEN) for a hart.
++- **get_vector_reg**: Fetch the contents of a vector register for a given hart.
++- **get_memory_at_VA**: Read a specified number of bytes from virtual memory at a given address for a hart, returning the data as a vector of the requested type.
++- **set_memory_at_VA**: Write a vector of values to virtual memory at a specified address for a hart, storing the data as the given type.
++
++### Additional Python Interface
++
++  The Hammer Python module, exposed via `pybind11`, also provides:
++
++- **Enums for Platform and CSR Registers**:The module exposes the `PlatformDefines` and `CsrDefines` enums, allowing you to refer to platform constants and a comprehensive set of RISC-V Control and Status Register (CSR) identifiers directly from Python. For example:
++
++  ```python
++  from builddir import hammer as pyhammer
++  csr_val = pyhammer.CsrDefines.MSTATUS_CSR
++  ```
++- **Memory Configuration and Memory Objects**:The classes `mem_cfg_t` and `mem_t` are available in Python for configuring memory regions and representing memory, respectively.
++
++  ```python
++  mem_cfg = pyhammer.mem_cfg_t(base_addr, size)
++  memory = pyhammer.mem_t(size)
++  ```
++- **hello_world**:
++  A simple method for testing the Python binding, which returns a greeting string from the Hammer backend.
++
++  ```python
++  print(hammer.hello_world())
++  ```
++
++## Modifying Hammer for Our Use Case
++
++With recent updates in Spike, several internal functions have changed their interface. As a result, our wrapper code around Spike had to be updated to reflect these **API changes**. This ensures compatibility and proper exposure of required functionality to Hammer.
++
++The curent changes are done to Hammer with Spike commit `113ef64f6724b769ef9298e6a4a9802f7671021f` (https://github.com/riscv-software-src/riscv-isa-sim/commit/113ef64f6724b769ef9298e6a4a9802f7671021f) as of August 1, 2025.
++
++With the recent updates in Spike, Hammer has been modified to accommodate these changes.
++
++# Modifications:
++
++## 1. What’s Added in This Fork ?
++
++| Area                                | Change                                                                                                                                                       | Why it matters                                                                                                                                                                                                                                                                                               |
++| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
++| **Instruction introspection** | `get_insn*` helpers (word, hex, length,string) & `get_opcode`, `get_rs1_addr`, `get_rs2_addr`, `get_rs3_addr`, `get_rd_addr`, `get_csr_addr`  | To get more information about the instruction decoded                                                                                                                                                                                                                                                        |
++| **RVC support**               | `get_rvc_opcode`, `get_rvc_rs*`, `get_rvc_rd_addr`                                                                                                     | Same as above but for 16‑bit compressed instructions                                                                                                                                                                                                                                                        |
++| **Commit‑log access**        | `get_log_commits_enabled`, `get_log_reg_writes`, `get_log_mem_reads`, `get_log_mem_writes`                                                           | `<ul><li>`Enables spike to log the instructions `</li><li>`Access register logs to extract register write data and export to interface `</li><li>`Access memory read and write logs to extract memory accesses and export to interface `</li><li>`Enable debugging and trace analysis `</li></ul>` |
++| **CSR access**                | `get_csr` now returns `std::optional<reg_t>`                                                                                                             | `<ul><li>`Avoids crashes on unimplemented CSRs instead of throwing access errors `</li><li>`Flexibility from interface side to check if a CSR instruction was executed or not `</li><li>`Provides a consistent interface for accessing CSR values `</li></ul>`                                       |
++| **Helper**                    | private `get_insn_fetch()`                                                                                                                                 | Centralises MMU fetch so helpers stay small                                                                                                                                                                                                                                                                  |
++| **Default logging**           | Spike log path now defaults to**`ham.log`** (Can be customised and compiled)                                                                               | Easy side‑by‑side core vs. cosim inspection                                                                                                                                                                                                                                                              |
++| **Build system**              | *Meson* tweaks: `-D_GNU_SOURCE`, relaxed unused‑* warnings, removed hard‑wired test dirs                                                               | Builds cleanly with recent Clang/GCC and Spike headers                                                                                                                                                                                                                                                       |
++| **Examples**                  | `hammer_example.py`, `hammer_run.py`                                                                                                                     | End‑to‑end demo: load ELF, single‑step, print decoded fields                                                                                                                                                                                                                                              |
++
++Files touched:
++
++```
++README.md            (this file)
++hammer.h             hammer.cpp
++hammer_pybind.cpp    meson.build
++native-file.txt      hammer_example.py
++hammer_run.py        tests/test000.cpp
++ham.log              (new default log)
++```
++
++**NOTE:** Since the Spike's API has changed, the existing tests in `tests/*` and `pytests/*` may need to be updated to reflect these changes. But to test the updated API , you can run `hammer_example.py` or `hammer_run.py` to see the new features in action.
++
++---
++
++## 2 · Extended C++ API
++
++```cpp
++ // New public methods on class Hammer
++bool                         get_log_commits_enabled(uint8_t hart);
++insn_t                       get_insn(uint8_t hart, reg_t pc);
++int                          get_insn_length(uint8_t hart, reg_t pc);
++uint64_t                     get_insn_hex(uint8_t hart, reg_t pc);
++std::string 		     get_insn_string(uint8_t hart_id,reg_t pc);
++
++uint64_t                     get_opcode(uint8_t hart, reg_t pc);
++uint64_t                     get_rs1_addr(uint8_t hart, reg_t pc);
++uint64_t                     get_rs2_addr(uint8_t hart, reg_t pc);
++uint64_t                     get_rs3_addr(uint8_t hart, reg_t pc);
++uint64_t                     get_rd_addr(uint8_t hart, reg_t pc);
++uint64_t                     get_csr_addr(uint8_t hart, reg_t pc);
++
++uint64_t                     get_rvc_opcode(uint8_t hart, reg_t pc);
++uint64_t                     get_rvc_rs1_addr(uint8_t hart, reg_t pc);
++uint64_t                     get_rvc_rs2_addr(uint8_t hart, reg_t pc);
++uint64_t                     get_rvc_rd_addr(uint8_t hart, reg_t pc);
++
++std::vector<std::pair<std::string,uint64_t>> get_log_reg_writes(uint8_t hart); // returns [register string name,data]
++commit_log_mem_t             get_log_mem_reads(uint8_t hart); // returns vector of [addr,data,size]
++commit_log_mem_t             get_log_mem_writes(uint8_t hart); //returns vector of [addr,data,size]
++std::optional<reg_t>         get_csr(uint8_t hart, uint32_t csr_id);
++```
++
++ **Observations:** When using `get_log_mem_reads()` , the returned `commit_log_mem_t` length is atleast 4 in all instruction executions. The address it read in my case was the address next to `<kernel_stack_end>`. The reason for this is not very clear, but it seems to be a quirk of the Spike simulator. But if the length is more than 4 , the first instructions that it reads will be the actual memory read instruction, so you can take all the vector pairs except the last four in the returned vector.
++
++```python
++        mem_reads=sim.get_log_mem_reads(0)
++        if mem_reads and len(mem_reads) > 4:
++            print("=== MEMORY READS ===")
++            for addr, value, size in mem_reads :
++                addr &= 0xFFFFFFFF  # Mask to 32 bits
++                print(f"READ ADDRESS: {addr:#x}, VALUE: {value:#x}, SIZE: {size} bytes")
++                break
++```
++
++---
++
++## 3 · Python Bindings
++
++All new C++ methods are exported 1‑to‑1 via Pybind11.
++
++```python
++import hammer, pathlib
++
++elf = pathlib.Path("./ibex_load_instr_test_0.o")
++mem = hammer.mem_cfg_t(0x8000_0000, 256 * 1024 * 1024)
++
++sim = hammer.Hammer("RV32IMC", "msu", "", [0], [mem], str(elf), None)
++
++for _ in range(10):
++    pc  = sim.get_PC(0)
++    raw = sim.get_insn_hex(0, pc)
++    opc = sim.get_opcode(0, pc)
++    print(f"PC={pc:08x}  insn={raw:08x}  opcode={opc:03x}")
++    sim.single_step(0)
++```
++
++---
++
++## 4 · Building
++
++Edit ~/.bashrc and add
++
++```bash
++export SPIKE_HOME=$HOME/hammer-deps/spike-install      # or whatever you used
++```
++
++to set the Spike install directory globally.
++
++Then run the following commands in your terminal
++
++### 1. Build and install Spike (exact commit below)
++
++Skip this step if you edited `~/.bashrc` to set `SPIKE_HOME`.
++
++```bash
++export SPIKE_HOME=$HOME/hammer-deps/spike-install      # or whatever you used
++
++git clone https://github.com/riscv-software-src/riscv-isa-sim
++cd riscv-isa-sim && git checkout 113ef64f
++mkdir build && cd build && ../configure --prefix=$SPIKE_HOME 
++make -j$(nproc)
++make install
++```
++
++### 2. Build Hammer
++
++```bash
++python3 -m pip install pybind11
++meson setup builddir   --bui
\ No newline at end of file
diff --git a/hammer.cpp b/hammer.cpp
index db48905..7af6ede 100644
--- a/hammer.cpp
+++ b/hammer.cpp
@@ -10,10 +10,11 @@
 
 #include <vector>
 
+
 // FIXME: This function exists in Spike as a static function. We shouldn't have to
 // copy it out here but sim_t requires it as an argument.
-static std::vector<std::pair<reg_t, mem_t *>> make_mems(const std::vector<mem_cfg_t> &layout) {
-  std::vector<std::pair<reg_t, mem_t *>> mems;
+static std::vector<std::pair<reg_t, abstract_mem_t*>> make_mems(const std::vector<mem_cfg_t> &layout) {
+  std::vector<std::pair<reg_t, abstract_mem_t*>> mems;
   mems.reserve(layout.size());
   for (const auto &cfg : layout) {
     mems.push_back(std::make_pair(cfg.get_base(), new mem_t(cfg.get_size())));
@@ -26,6 +27,8 @@ Hammer::Hammer(const char *isa, const char *privilege_levels, const char *vector
                const std::string target_binary, const std::optional<uint64_t> start_pc) {
   // Expose these only if needed
   std::vector<std::pair<reg_t, abstract_device_t *>> plugin_devices;
+  std::vector<std::pair<const device_factory_t*, std::vector<std::string>>> plugin_device_factories;
+
   debug_module_config_t dm_config = {.progbufsize = 2,
                                      .max_sba_data_width = 0,
                                      .require_authentication = false,
@@ -34,29 +37,51 @@ Hammer::Hammer(const char *isa, const char *privilege_levels, const char *vector
                                      .support_abstract_csr_access = true,
                                      .support_haltgroups = true,
                                      .support_impebreak = true};
-  const char *log_path = nullptr;
+  const char *log_path = "../ham.log";
   const char *dtb_file = nullptr;
   FILE *cmd_file = nullptr;
 
-  std::pair<reg_t, reg_t> initrd_bounds{0, 0};
-  const char *bootargs = nullptr;
-  bool real_time_clint = false;
-  bool misaligned = false;
+  // std::pair<reg_t, reg_t> initrd_bounds{0, 0};
+  // const char *bootargs = nullptr;
+  // bool real_time_clint = false;
+  // bool misaligned = false;
+  // bool explicit_hartids =false;
+
+  // reg_t trigger_count = 4;
+
+  // reg_t num_pmpregions = 16;
+
+  // reg_t pmpgranularity   = (1 << PMP_SHIFT);
+
+  // reg_t cache_blocksz = 64;
 
-  reg_t trigger_count = 4;
+  // endianness_t endinaness = endianness_little;
 
-  reg_t num_pmpregions = 16;
+  // cfg_t cfg = cfg_t(initrd_bounds, bootargs, isa, privilege_levels, vector_arch, misaligned, endinaness, num_pmpregions, memory_layout,
+  //                   hart_ids, real_time_clint, trigger_count);
 
-  endianness_t endinaness = endianness_little;
+  cfg_t cfg; // Spike Commit 6023896 revised the cfg_t class
+  // cfg.initrd_bounds    = initrd_bounds;
+  // cfg.bootargs         = bootargs;
+  cfg.isa              = isa;
+  cfg.priv             = privilege_levels;
+  // cfg.misaligned       = misaligned;
+  // cfg.endianness       = endinaness;
+  // cfg.pmpregions       = num_pmpregions;
+  // cfg.pmpgranularity   = pmpgranularity;
+  cfg.mem_layout       = memory_layout;
+  cfg.hartids          = hart_ids;
+  // cfg.explicit_hartids = explicit_hartids;
+  // cfg.real_time_clint  = real_time_clint;
+  // cfg.trigger_count    = trigger_count;
+  // cfg.cache_blocksz    = cache_blocksz;
 
-  cfg_t cfg = cfg_t(initrd_bounds, bootargs, isa, privilege_levels, vector_arch, misaligned, endinaness, num_pmpregions, memory_layout,
-                    hart_ids, real_time_clint, trigger_count);
 
   if (start_pc.has_value()) {
     cfg.start_pc = start_pc.value();
   }
 
-  std::vector<std::pair<reg_t, mem_t *>> mems = make_mems(memory_layout);
+  std::vector<std::pair<reg_t, abstract_mem_t*>> mems = make_mems(memory_layout);
 
   std::vector<std::string> htif_args;
   htif_args.push_back(target_binary);
@@ -64,16 +89,214 @@ Hammer::Hammer(const char *isa, const char *privilege_levels, const char *vector
   bool halted = false;
   bool dtb_enabled = true;
   bool socket_enabled = false;
+  std::optional<unsigned long long> instructions = std::nullopt;
 
-  simulator = new sim_t(&cfg, halted, mems, plugin_devices, htif_args, dm_config, log_path,
-                        dtb_enabled, dtb_file, socket_enabled, cmd_file);
+  // simulator = new sim_t(&cfg, halted, mems, plugin_devices, htif_args, dm_config, log_path,
+  //                       dtb_enabled, dtb_file, socket_enabled, cmd_file);
+  simulator = new sim_t(&cfg, halted, mems, plugin_device_factories, htif_args, dm_config, log_path,
+                        dtb_enabled, dtb_file, socket_enabled, cmd_file,instructions);
 
   // Initializes everything
+  bool enable_log=false;
+  bool enable_commitlog=true;
+  simulator->configure_log(enable_log,enable_commitlog);
   simulator->start();
 }
 
 Hammer::~Hammer() { delete simulator; }
 
+bool Hammer::get_log_commits_enabled(uint8_t hart_id){
+  processor_t *hart = simulator->get_core(hart_id);
+  return hart->get_log_commits_enabled();
+}
+
+// Instruction metadata
+insn_fetch_t Hammer::get_insn_fetch(uint8_t hart_id,reg_t pc){
+  processor_t *hart = simulator->get_core(hart_id);
+  mmu_t *mmu = hart->get_mmu();
+  insn_fetch_t fetch = mmu->load_insn(pc);
+  return fetch;
+}
+
+std::string Hammer::get_insn_string(uint8_t hart_id,reg_t pc) {
+  processor_t *hart = simulator->get_core(hart_id);
+  mmu_t *mmu = hart->get_mmu();
+  insn_fetch_t fetch = mmu->load_insn(pc);
+  insn_t insn = fetch.insn;
+  const disassembler_t *disasm = hart->get_disassembler();
+  std::string insn_str = disasm->disassemble(insn);
+  return insn_str;
+}
+
+insn_t Hammer::get_insn(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn;
+}
+insn_bits_t Hammer::get_insn_hex(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.bits();
+}
+int Hammer::get_insn_length(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.length();
+}
+uint64_t Hammer::get_opcode(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.opcode();
+}
+
+uint64_t Hammer::get_rs1_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rs1();
+}
+uint64_t Hammer::get_rs2_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rs2();
+}
+uint64_t Hammer::get_rs3_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rs3();
+}
+uint64_t Hammer::get_rd_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rd();
+}
+uint64_t Hammer::get_csr_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.csr();
+}
+
+// RVC instructions metadata
+uint64_t Hammer::get_rvc_opcode(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rvc_opcode();
+}
+uint64_t Hammer::get_rvc_rs1_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rvc_rs1();
+}
+
+uint64_t Hammer::get_rvc_rs2_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rvc_rs2();
+}
+
+uint64_t Hammer::get_rvc_rd_addr(uint8_t hart_id,reg_t pc){
+  return get_insn_fetch(hart_id,pc).insn.rvc_rd();
+}
+
+std::vector<std::pair<std::string, uint64_t>> Hammer::get_log_reg_writes(uint8_t hart_id){
+  processor_t *hart = simulator->get_core(hart_id);
+  commit_log_reg_t reg = hart->get_state()->log_reg_write;
+  int xlen = hart->get_state()->last_inst_xlen;
+  int flen = hart->get_state()->last_inst_flen;
+  bool show_vec = false;
+  
+  std::vector<std::pair<std::string, uint64_t>> result;
+  
+  for (auto item : reg) {
+    if (item.first == 0)
+      continue;
+
+    char prefix = ' ';
+    int size;
+    int rd = item.first >> 4;
+    bool is_vec = false;
+    bool is_vreg = false;
+    
+    // Determine register type and size (same logic as Spike)
+    switch (item.first & 0xf) {
+    case 0:
+      size = xlen;
+      prefix = 'x';
+      break;
+    case 1:
+      size = flen;
+      prefix = 'f';
+      break;
+    case 2:
+      size = hart->VU.get_vlen();
+      prefix = 'v';
+      is_vreg = true;
+      break;
+    case 3:
+      is_vec = true;
+      break;
+    case 4:
+      size = xlen;
+      prefix = 'c';
+      break;
+    default:
+      continue; // Skip unknown register types
+    }
+    // NOT RELEVANT FOR RV32IMC
+    if (!show_vec && (is_vreg || is_vec)) {
+        // log write 
+        show_vec = true;
+    }
+
+    if (!is_vec) {
+      // Create register name
+      std::string reg_name = std::string(1, prefix) + std::to_string(rd);
+      
+      // Extract the integer value directly from the register data
+      uint64_t int_value = 0;
+      if (size <= 64) {
+        // For 32-bit and 64-bit registers, use v[0]
+        int_value = item.second.v[0];
+        if (size == 32) {
+          // For 32-bit registers, mask to 32 bits
+          int_value &= 0xFFFFFFFF;
+        }
+      } else {
+        // For larger registers (like 128-bit), combine v[0] and v[1]
+        int_value = item.second.v[0] | (static_cast<uint64_t>(item.second.v[1]) << 32);
+      }
+      
+      // std::cout<<"Reg"<<" "<<reg_name<<" "<<"Value:"<<std::hex<<"0x"<<int_value<<std::dec<<std::endl;
+      result.emplace_back(reg_name, int_value);
+    }
+  }
+  
+  return result;
+}
+commit_log_mem_t Hammer::get_log_mem_reads(uint8_t hart_id){
+    commit_log_mem_t result;
+    processor_t *hart = simulator->get_core(hart_id);
+    commit_log_mem_t load = hart->get_state()->log_mem_read;
+    
+    // if (!load.empty()) {
+    //     std::cout << "=== MEMORY READS for PC: 0x" << std::hex << get_PC(hart_id) << std::dec << " ===" << std::endl;
+    // }
+    
+    //address,data,size
+    for (auto item : load) {
+      // item is a tuple: <address, value, size>
+      reg_t addr = std::get<0>(item);
+      uint64_t value = std::get<1>(item);
+      uint8_t size = std::get<2>(item);
+      
+      // std::cout<<std::hex<<"ADDR 0x"<<addr<<" value 0x"<<value<<" size "<<std::dec<<(int)size<<" bytes"<<std::endl;
+      // Add to result as a tuple
+      result.emplace_back(addr, value, size);
+    }
+    return result;
+
+}
+
+commit_log_mem_t Hammer::get_log_mem_writes(uint8_t hart_id){
+    commit_log_mem_t result;
+    processor_t *hart = simulator->get_core(hart_id);
+    commit_log_mem_t store = hart->get_state()->log_mem_write;
+    
+    // if (!store.empty()) {
+    //     std::cout << "=== MEMORY WRITES ===" << std::endl;
+    // }
+    
+    //address,data,size
+    for (auto item : store) {
+      // item is a tuple: <address, value, size>
+      reg_t addr = std::get<0>(item);
+      uint64_t value = std::get<1>(item);
+      uint8_t size = std::get<2>(item);
+      
+      // std::cout<<std::hex<<"WRITE ADDR 0x"<<addr<<" value 0x"<<value<<" size "<<std::dec<<(int)size<<" bytes"<<std::endl;
+      // Add to result as a tuple
+      result.emplace_back(addr, value, size);
+    }
+    return result;
+}
+
+
+
 reg_t Hammer::get_gpr(uint8_t hart_id, uint8_t gpr_id) {
   assert(gpr_id < NXPR);
 
@@ -116,9 +339,14 @@ void Hammer::set_PC(uint8_t hart_id, reg_t new_pc_value) {
   hart_state->pc = new_pc_value;
 }
 
-reg_t Hammer::get_csr(uint8_t hart_id, uint32_t csr_id) {
+std::optional<reg_t> Hammer::get_csr(uint8_t hart_id, uint32_t csr_id) {
   processor_t *hart = simulator->get_core(hart_id);
-  return hart->get_csr(csr_id);
+  try {
+    return hart->get_csr(csr_id);
+  } catch (...) {
+    // Return nullopt for invalid/non-existent CSRs
+    return std::nullopt;
+  }
 }
 
 void Hammer::single_step(uint8_t hart_id) {
diff --git a/hammer.h b/hammer.h
index 654a267..0525c19 100644
--- a/hammer.h
+++ b/hammer.h
@@ -3,10 +3,15 @@
 // SPDX-License-Identifier: Apache-2.0
 
 #pragma once
-
+// #define _GNU_SOURCE        // redundant but harmless alongside the -D flag
+#include <sys/syscall.h>   // brings in SYS_futex on glibc
+// #include <linux/futex.h>   // (optional) gives FUTEX_* enums if you ever need them 
 #include "hammer_enums.h"
+#include "riscv/devices.h"        // device_factory_t
 #include "riscv/mmu.h"
 #include "riscv/sim.h"
+#include "riscv/disasm.h"
+
 
 #include <iostream>
 
@@ -17,6 +22,32 @@ class Hammer {
          const std::string target_binary, const std::optional<uint64_t> start_pc = std::nullopt);
   ~Hammer();
 
+  bool get_log_commits_enabled(uint8_t hart_id);
+  
+  std::string get_insn_string(uint8_t hart_id,reg_t pc);
+  insn_t get_insn(uint8_t hart_id,reg_t pc);
+  int get_insn_length(uint8_t hart_id,reg_t pc);
+  insn_bits_t get_insn_hex(uint8_t hart_id,reg_t pc);
+  u_int64_t get_opcode(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rs1_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rs2_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rs3_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rd_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_csr_addr(uint8_t hart_id,reg_t pc);
+  
+  //RVC instructions
+  u_int64_t get_rvc_opcode(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rvc_rs1_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rvc_rs2_addr(uint8_t hart_id,reg_t pc);
+  u_int64_t get_rvc_rd_addr(uint8_t hart_id,reg_t pc);
+  
+  // Detailed register write logging (like Spike's commit log)
+  std::vector<std::pair<std::string, uint64_t>> get_log_reg_writes(uint8_t hart_id);
+  commit_log_mem_t get_log_mem_reads(uint8_t hart_id);
+  commit_log_mem_t get_log_mem_writes(uint8_t hart_id);
+  
+  
+  
   reg_t get_gpr(uint8_t hart_id, uint8_t gpr_id);
   void set_gpr(uint8_t hart_id, uint8_t gpr_id, reg_t new_gpr_value);
 
@@ -25,7 +56,7 @@ class Hammer {
   reg_t get_PC(uint8_t hart_id);
   void set_PC(uint8_t hart_id, reg_t new_pc_value);
 
-  reg_t get_csr(uint8_t hart_id, uint32_t csr_id);
+  std::optional<reg_t> get_csr(uint8_t hart_id, uint32_t csr_id);
 
   void single_step(uint8_t hart_id);
 
@@ -71,4 +102,5 @@ class Hammer {
 
  private:
   sim_t *simulator;
+  insn_fetch_t get_insn_fetch(uint8_t hart_id,reg_t pc);
 };
diff --git a/hammer_example.py b/hammer_example.py
new file mode 100644
index 0000000..1e0d89c
--- /dev/null
+++ b/hammer_example.py
@@ -0,0 +1,101 @@
+#!/usr/bin/env python3
+"""
+Quick sanity script for the Hammer ⇆ Spike wrapper.
+
+Usage:
+    python hammer_example.py path/to/program.elf
+
+Make sure:
+  * $LD_LIBRARY_PATH contains <SPIKE_PREFIX>/lib
+  * The `hammer` extension (built with Meson) is discoverable in PYTHONPATH or installed.
+"""
+
+import sys
+import hammer
+
+def main():
+    if len(sys.argv) < 2:
+        print("Usage: python hammer_example.py <prog.elf>")
+        sys.exit(1)
+
+    elf = sys.argv[1]
+    print(f"Loading ELF: {elf}")
+
+    mem_cfg = hammer.mem_cfg_t(hammer.DramBase, 256 * 1024 * 1024)
+
+    sim = hammer.Hammer(
+        "RV32IMC",          # arg0: isa
+        "msu",              # arg1: privilege_levels  
+        "",                 # arg2: vector_arch
+        [0],                # arg3: hart_ids
+        [mem_cfg],          # arg4: memory_layout (sequence of mem_cfg_t)
+        elf,                # arg5: target_binary
+        None                # arg6: start_pc (optional)
+    )
+
+    print("Initial PC:", hex(sim.get_PC(0)))
+
+    # Step through first 10 instructions
+    for i in range(300):
+        hart=0
+
+        pc  = sim.get_PC(0) & 0xFFFFFFFF  # RV32IMC, so we mask to 32 bits
+        insn_hex = sim.get_insn_hex(0, pc)
+        insn_str = sim.get_insn_string(0, pc)
+        # print(dir(insn_str))
+        rs1 = sim.get_rs1_addr(0, pc)
+        rs2 = sim.get_rs2_addr(0, pc)
+        rs3 = sim.get_rs3_addr(0, pc)
+        rd  = sim.get_rd_addr(0, pc)
+        csr = sim.get_csr_addr(0, pc)
+        csr_val = sim.get_csr(0, csr)
+        length = sim.get_insn_length(0, pc)
+        enable = sim.get_log_commits_enabled(0)
+        # Handle optional CSR value (None if invalid CSR)
+        if csr_val is None:
+            csr_val = "N/A"
+
+        sim.single_step(0)
+        
+
+        a0  = sim.get_gpr(0, 10)   # x10/a0
+        val_a = sim.get_memory_at_VA(0, 0x8000bc48, 4, 1)
+        val = 0
+        if val_a is not None:
+            for byte_value in val_a:
+                val |= (byte_value << (val_a.index(byte_value) * 8))
+        
+        print(f"Step {i+1:02d}: pc={pc:#x} insn={insn_hex:#x}")
+        print(f"  insn_str: {insn_str}")
+        reg_writes=sim.get_log_reg_writes(0)  # Dump the state of hart 0
+        if reg_writes:
+            print("=== REGISTER WRITES ===")
+            for reg, value in reg_writes:
+                print(f"WRITE REG: {reg}, VALUE: {value:#x}")
+
+        mem_reads=sim.get_log_mem_reads(0)
+        if mem_reads and len(mem_reads) > 4:
+            print("=== MEMORY READS ===")
+            for addr, value, size in mem_reads :
+                addr &= 0xFFFFFFFF  # Mask to 32 bits
+                print(f"READ ADDRESS: {addr:#x}, VALUE: {value:#x}, SIZE: {size} bytes")
+                break
+        mem_writes=sim.get_log_mem_writes(0)
+        if mem_writes:
+            print("=== MEMORY WRITES ===")
+            for addr, value, size in mem_writes:
+                addr &= 0xFFFFFFFF  # Mask to 32 bits
+                print(f"WRITE ADDRESS: {addr:#x}, VALUE: {value:#x}, SIZE: {size} bytes")
+        memory_contents = sim.get_memory_at_VA(0, 0x80002000, 4, 1)
+        value_at_address = 0
+        x = 0
+        if memory_contents is not None:
+            for byte_value in memory_contents:
+                value_at_address |= (byte_value << (x * 8))
+                x += 1
+        if value_at_address==1:
+            print("Reached target memory location, stopping simulation.")
+            break
+
+if __name__ == "__main__":
+    main()
diff --git a/hammer_pybind.cpp b/hammer_pybind.cpp
index 495cb9d..1b36af7 100644
--- a/hammer_pybind.cpp
+++ b/hammer_pybind.cpp
@@ -19,6 +19,30 @@ PYBIND11_MODULE(hammer, m) {
                           std::vector<mem_cfg_t>, const std::string,
                           const std::optional<uint64_t>>())
       .def("hello_world", &Hammer::hello_world)
+      .def("get_log_commits_enabled",&Hammer::get_log_commits_enabled)
+      
+      .def("get_insn_hex",&Hammer::get_insn_hex)
+      .def("get_insn_string",&Hammer::get_insn_string)
+      .def("get_insn",&Hammer::get_insn)
+      .def("get_insn_length",&Hammer::get_insn_length)
+      .def("get_opcode",&Hammer::get_opcode)
+      .def("get_rs1_addr",&Hammer::get_rs1_addr)
+      .def("get_rs2_addr",&Hammer::get_rs2_addr)
+      .def("get_rs3_addr",&Hammer::get_rs3_addr)
+      .def("get_rd_addr",&Hammer::get_rd_addr)
+      .def("get_csr_addr",&Hammer::get_csr_addr)
+
+      //RVC
+      .def("get_rvc_opcode",&Hammer::get_rvc_opcode)
+      .def("get_rvc_rs1_addr",&Hammer::get_rvc_rs1_addr)
+      .def("get_rvc_rs2_addr",&Hammer::get_rvc_rs2_addr)
+      .def("get_rvc_rd_addr",&Hammer::get_rvc_rd_addr)
+        
+      .def("get_log_reg_writes",&Hammer::get_log_reg_writes)
+      .def("get_log_mem_reads",&Hammer::get_log_mem_reads)
+      .def("get_log_mem_writes",&Hammer::get_log_mem_writes)
+
+      
       .def("get_gpr", &Hammer::get_gpr)
       .def("set_gpr", &Hammer::set_gpr)
       .def("get_fpr", &Hammer::get_fpr)
diff --git a/hammer_run.py b/hammer_run.py
new file mode 100644
index 0000000..b44b71c
--- /dev/null
+++ b/hammer_run.py
@@ -0,0 +1,21 @@
+import hammer, pathlib, sys
+
+# print(dir(hammer))
+# elf = sys.argv[1]
+elf = "./ibex_load_instr_test_0.o"
+
+# Build one mem_cfg_t object – (base, size) just like the C++ struct
+mem_cfg = hammer.mem_cfg_t(0x8000_0000, 256 * 1024 * 1024)   # 256 MiB DRAM
+
+# print(dir(hammer.Hammer))
+
+#               0           1           2       3       4           5     [6]
+sim = hammer.Hammer("RV32IMC", "msu",   "",   [0],  [mem_cfg],elf,None) 
+#                ↑          ↑           ↑     ↑       ↑           ↑     ↑
+#                isa   privilege_levels  vlen hartIDs  mem_layout  ELF  (start_pc optional)
+
+print("Simulator Instantiated")
+# print("Initial PC:", hex(sim.get_PC(0)))
+# for i in range(10):
+#     sim.single_step(0)
+#     print(f"{i+1:02}: pc={hex(sim.get_PC(0))}")
diff --git a/ibex_load_instr_test_0.o b/ibex_load_instr_test_0.o
new file mode 100755
index 0000000..f24baf6
Binary files /dev/null and b/ibex_load_instr_test_0.o differ
diff --git a/meson.build b/meson.build
index fd21cba..6b0d603 100644
--- a/meson.build
+++ b/meson.build
@@ -10,6 +10,13 @@ project('hammer lib', 'cpp',
           'default_library=static'
           ]
         )
+add_project_arguments(
+  ['-D_GNU_SOURCE',
+   '-Wno-error=unused-variable',
+   '-Wno-error=unused-parameter'],
+  language: 'cpp')
+# Added additionally 
+
 
 spike_install_dir = get_option('spike_install_dir')
 
@@ -86,5 +93,3 @@ hammer_pylib = python3_instance.extension_module('hammer',
 
 install_headers('hammer.h', 'hammer_enums.h')
 
-subdir('tests')
-subdir('pytests')
diff --git a/native-file.txt b/native-file.txt
index b0d620f..635f844 100644
--- a/native-file.txt
+++ b/native-file.txt
@@ -4,6 +4,11 @@
 
 # GCC has trouble with some of the compiler flags so use clang instead.
 
+#[binaries]
+#cc = 'clang'
+#cpp = 'clang++'
 [binaries]
-cc = 'clang'
-cpp = 'clang++'
+c   = '/usr/bin/gcc'
+cpp = '/usr/bin/g++'
+ar  = '/usr/bin/ar'
+strip = '/usr/bin/strip'
\ No newline at end of file
diff --git a/tests/test000.cpp b/tests/test000.cpp
index 2050763..e82f69c 100644
--- a/tests/test000.cpp
+++ b/tests/test000.cpp
@@ -69,7 +69,12 @@ int main(int argc, char *argv[]) {
     hammer.single_step(0);
   }
 
-  reg_t current_mstatus = hammer.get_csr(0, MSTATUS_CSR);
+  auto mstatus_opt = hammer.get_csr(0, MSTATUS_CSR);
+  if (!mstatus_opt.has_value()) {
+    printf("Failed to read mstatus CSR\n");
+    exit(1);
+  }
+  reg_t current_mstatus = mstatus_opt.value();
   if (current_mstatus != 0x8000000a00002600) {
     printf("Unexpected mstatus: 0x%" PRIx64 "\n", current_mstatus);
     exit(1);
